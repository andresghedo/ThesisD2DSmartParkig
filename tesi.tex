%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
\usepackage[labelfont=bf]{caption}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come è à
                                        %   si può usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   però con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{}                          %serve per la sillabazione
\theoremstyle{plain}                    %stile corsivo
\newtheorem{teo}{Teorema}[section]      %definizione ambiente teorema
\newtheorem{prop}[teo]{Proposizione}    %definizione ambiente proposizione
\newtheorem{cor}[teo]{Corollario}       %definizione ambiente corollario
\newtheorem{lem}[teo]{Lemma}            %definizione ambiente lemma
\theoremstyle{definition}               %stile roman
\newtheorem{defin}{Definizione}[chapter]%definizione ambiente definizione
\newtheorem{ese}{Esempio}[chapter]      %definizione ambiente esempio
\theoremstyle{remark}                   %stile per osservazioni
\newtheorem{oss}{Osservazione}          %definizione ambiente osservazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
\newcommand{\df}{\displaystyle\frac}    %crea un comando che visualizza le
                                        %   frazioni in modo più esteso
\newcommand{\seq}[1]{\left<#1\right>}   %crea un comando per il "generato"
                                        %   di un insieme, per richiamarlo
                                        %   si può scrivere ad esempio:
                                        %           $\seq{q_1,q_2}$\
\begin{document}
\begin{titlepage}                       %crea un ambiente libero da vincoli
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Alla mia famiglia...

\newpage                                %va in una pagina nuova
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\end{titlepage}
\pagenumbering{roman}                   %serve per mettere i numeri romani
\chapter*{Introduzione}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Introduzione}
Oggigiorno, il numero di veicoli presenti nelle metropoli ha raggiunto quantità tali da portare problemi di congestione del traffico.
Si stima che una buona parte della congestione sia causata da automobilisti alla ricerca costante di un parcheggio libero.
Questa problematica causa una serie di negative conseguenze, danneggiando progressivamente gli utenti e l'ambiente.
La ricerca prolungata di uno slot libero comporta all'utente perdita di tempo e di denaro, contribuendo ad un peggioramento, anche se leggero, della qualità di vita nelle grandi città.
Inoltre, sono evidenti le conseguenze negative sull'impatto ambientale, dove la qualità dell'aria viene messa costantemente a rischio dall'enorme quantità 
di carburante che viene consumato, producendo emissioni di agenti inquinanti nell'atmosfera.
Enti governativi stanno iniziando a prendere in considerazione queste problematiche, cercando di trovare le giuste soluzioni per migliorare la situazione.
In questo senso, numerose proposte sono già presenti in letteratura, basandosi sui concetti innovativi di Smart Parking, IoT(Internet of Things) e Smart City.
Infrastrutture informatiche, comunicazione tra dispositivi eterogenei e sensoristica sono tutti elementi che possono favorire un miglior utilizzo dei parcheggi, 
fornendo agli utenti importanti indicazioni sullo stato degli slot, in una determinata zona.
Queste diventano fondamentali soprattutto se si considerano parcheggi su strada (on-street parking), i quali sono limitati e non circoscritti in precisi punti 
(al contrario di parcheggi-garage e sistemi a circuito chiuso, in cui tramite semplici apparecchiatura è possibile contare il numero di veicoli in entrata ed in uscita).
Molte soluzioni proposte prevedono l'utilizzo di sensori su strada o telecamere per comprendere l'occupazione o meno di un determinato parcheggio.
Mentre per la disseminazione delle informazioni raccolte, si propongono sistemi decentralizzati basati sull'IoT e WSN(Wireless Sensor Network), oppure classici sistemi centralizzati.
Tutti questi componenti prevedono un investimento iniziale enorme per apparecchiature ed installazione, senza contare i futuri e necessari costi di manutenzione.
Questo è ovviamente un grosso limite per i governi che spesso non sono intenzionati ad utilizzare ingenti fondi per questi scopi.
\\Il sistema che viene proposto non necessita di alcuna infrastruttura particolare e si pone l'obiettivo di fornire all'utente una stima sulle zone più dense di parcheggi liberi della città.
Questo è reso possibile tramite il concetto di Crowdsensing, dove gli utenti condividono le proprie rilevazioni con altri utenti e grazie a questi continui contributi, il singolo riesce a fare 
assunzioni sulla situazione parcheggi in città.
Ogni Smartphone, avendo la possibilità di rilevare il tipo di mobilità dell'utente tramite i propri sensori, riesce a dedurre in probabilità un evento di parcheggio, piuttosto che di rilascio. 
Questi dati vengono disseminati localmente nell'ambiente ad altri device in maniera totalmente decentralizzata, permettendo agli utenti di restare aggiornati sulla situazione 
parcheggio nelle zone limitrofe.
Il servizio, una volta avviato, non avrà bisogno di alcuna interazione utente, in quanto il processo di rilevazione e di comunicazione sono stati automatizzati.
\\Questo documento viene organizzato in quattro capitoli, secondo la seguente struttura. Nel primo capitolo viene analizzato lo stato dell'arte per quanto riguarda l'argomento in questione. 
Il secondo capitolo illustra i passi di progettazione necessari alla realizzazione del sistema. Il terzo capitolo riguarda l'implementazione dell'applicazione Android, entrando nei dettagli più 
tecnici. Il quarto ed ultimo capitolo mostra la valutazione del sistema, dove i risultati sono stati ottenuti simulando il funzionamento del sistema in una città metropolitana.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoffigures                          %crea l'elenco delle figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoftables                           %crea l'elenco delle tabelle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
\clearpage{\pagestyle{empty}\cleardoublepage}
\part{Stato dell'arte}
\chapter{Stato dell'arte} 
Il seguente capitolo illustra il contesto in cui si colloca il progetto di tesi ed una serie di lavori correlati sull'argomento dello Smart Parking.
\section{Sistemi di Trasporto Intelligenti}
Il Ministero delle Infrastrutture e dei Trasporti definisce gli Intelligent Transport System (ITS, in italiano Sistemi di Trasporto Intelligenti) come 
\textit{``...range di strumenti per la gestione delle reti di trasporto, così come i servizi per i viaggiatori. Gli strumenti ITS sono basati su tre aspetti centrali: 
acquisizione, elaborazione e diffusione delle informazioni e da un minimo comune denominatore quale è l'integrazione.
I processi di acquisizione dei dati, l'elaborazione e l'integrazione degli stessi e la catena delle informazioni da fornire agli utenti del sistema di trasporto sono il cuore dei sistemi ITS''}[1].
Lo sviluppo esponenziale dell'informatica e delle reti di comunicazione ha portato alla nascita di numerose applicazione, ad alto contenuto tecnologico, per la gestione ed il controllo nell'ambito trasporti.
La gestione del traffico veicolare (acquisizione dei dati di traffico, controllo semaforico, controllo degli accessi, gestione dei parcheggi), del trasporto collettivo e della logistica (indicazioni di percorso e 
instradamento parcheggi, sistemi di distribuzione delle merci, sistemi misti merci/passeggeri, ecc...) sono esempi tangibili di come i sistemi ITS stiano diventando uno strumento prezioso per il controllo della mobilità.
Le città metropolitane sono sovraffollate di veicoli, portando a costanti situazioni di inefficienza dei trasporti, congestione del traffico ed un aumento dei tempi di percorrenza per giungere a destinazione. 
Questa situazione è in costante aumento in tutto il mondo, data l'urbanizzazione e la crescente densità di popolazione nelle grandi città.
Il 54\% della popolazione mondiale risiede in città metropolitane e si stima che possa diventare il 66\% entro il 2050[2].
\begin{figure}[!h]
\centering
\includegraphics[scale=0.7]{img/its.jpg}
\caption[Esempio di ITS]{Esempio di ITS}
\end{figure}
I sistemi ITS si pongono l'obiettivo di migliorare la qualità dei trasporti in termini di riduzione delle congestioni, rischi di incidente e situazioni di emergenza.
Per fare ciò vengono sfruttati meccanismi intelligenti, in grado di fare determinate assunzioni sulla base delle informazione scambiate tra veicoli che si trovano in una determinata zona.
Gli utenti, sfruttando le deduzioni offerte da questi sistemi, potrebbero variare il loro comportamento, permettendo così di smaltire le congestioni e favorire la viabilità generale.
\section{Crowdsensing}
Per Crowdsensing si definisce quell'attività di condivisione e raccolta dati, utilizzando i vari sensori presenti all'interno dei dispositivi mobili. Lo scopo di ogni device deve essere quello 
di condividere con molti utenti le proprie informazioni.
In questa maniera, si potrà giungere ad una conoscenza condivisa tra gli utenti ed ottenere, in maniera intelligente, i risultati prefissati.
Il Crowdsensing si suddivide principalmente in 2 categorie[3]:
\begin{itemize}
\item \textit{Partecipatory Crowdsensing} : l'utente viene coinvolto direttamente nella fase di propagazione dei dati. 
\item \textit{Opportunistic Crowdsensing} : la propagazione avviene in maniera automatica e trasparente all'utente.
\end{itemize}
La seconda categoria, dove l'utente deve solo accettare la condivisione dei propri dati, è quella maggiormente utilizzata nelle applicazioni mobili, in quanto è quella che garantisce una buona quantità di raccolta dati.
\\Il Crowdsensing può essere uno strumento molto potente per ottenere risultati che possono essere ricavati soltanto dall'aggregazione di dati collettivi.
Numerosi contributi, in letteratura, si basano proprio su questo concetto. Ad esempio, il progetto in [4] utilizza il concetto di Crowdsensing per la costruzione intelligente di mappe indicanti il 
numero di parcheggi disponibili per una determinata strada.
In questo caso, prendendo un numero elevato di utenti in una determinata zona e condividendo i dati di dove essi parcheggiano abitualmente, è possibile  tracciare le zone adibite al parcheggio di una 
determinata strada.
Il sistema presentato in [8], vuole fornire agli utenti la situazione di occupazione del parcheggio universitario tramite i dati raccolti dagli utenti.
Ogni studente, quando lascia il parcheggio, contribuisce alla conoscenza globale con la propria visione del parcheggio (pieno, semi-pieno, vuoto).
I lavori proposti sul tema dello Smart Parking in [6][9], mostrano quanto sia fondamentale il tasso di partecipazione utente.
Più utenti condividono le proprie informazioni, più l'accuratezza dei risultati sarà precisa. In particolare viene mostrato che un alto tasso di partecipazione corrisponde ad una diminuzione notevole del tempo di ricerca 
di un parcheggio.
Ogni utente condivide i propri dati sapendo di contribuire al risultato generale, avendo l'interesse nel migliorarne l'accuratezza.
Le applicazioni Crowdsensing rappresentano una possibilità di migliorare la quotidianità dell'individuo.
\section{Smart City}
La \textit{IEEE} definisce la Smart City come ambiente sostenibile in grado di ridurre i consumi e fornire una qualità di vita migliore ai cittadini[18].
Il mondo tecnologico, i governi e la società dovrebbero favorire in maniera positiva il processo di urbanizzazione, riuscendo a proporre le seguenti caratteristiche nella città intelligente:
\begin{itemize}
\item smart mobility
\item smart economy
\item smart environment
\item smart people
\item smart living
\item smart governance
\end{itemize}
La Smart City si pone l'obiettivo di semplificare ogni operazione della città, grazie agli ultimi sviluppi tecnologici.
Soprattutto la recente espansione del paradigma \textit{IoT} (Internet of Things, in italiano Internet delle Cose) ha permesso l'apertura verso nuove applicazioni, in grado di portare miglioramenti nella vita metropolitana.
In [19], si definisce l'Internet delle Cose come \textit{``l'interconnessione in rete di oggetti di uso quotidiano, formando una rete distribuita di dispositivi, comunicanti con l'uomo o con altri dispositivi''}.
\\Ogni dispositivo potrà aumentare il proprio livello di intelligenza grazie all'interconnessione ed alle informazioni derivanti da altri device.
\\Il progetto di tesi può essere visto come un primo passo verso il tema dello Smart City, dove numerosi dispositivi vengono coinvolti per migliorare un aspetto quotidiano dei cittadini.
\section{Smart Parking}
Il problema del parcheggio può essere visto come una grossa sfida all'interno delle Città intelligenti, definite nella sezione 1.3.
Con il termine Smart Parking si intendono tutte quelle soluzioni che potrebbero favorire l'utente nell'attività di parcheggio.
Secondo recenti studi, la maggior parte della congestione veicolare nelle grandi città è causata dai parcheggi.
Gli utenti passano molto tempo nel cercare uno slot libero, soprattutto se si considerano parcheggi su strada (on-street parking).
\\Le conseguenze negative di tutto ciò si possono riassumere in:
\begin{itemize}
\item perdita di tempo
\item perdita di denaro
\item inquinamento ambientale
\item peggioramento della qualità di vita
\end{itemize}
Lo studio in [4], quantifica gli effetti negativi evidenziando come in una porzione di Los Angeles, nel periodo di un anno, le macchine abbiano compiuto una distanza pari a 
37 giri intorno al mondo, soltanto per le attività di ricerca parcheggio.
Questo ha portato al consumo di 47000 galloni di gasolio, tramutati in 730 tonnellate di CO\ped{2} (diossido di carbonio) emesso nell'aria.
Un'altra analisi molto interessante viene fatta in [5], dove si dimostra come gli utenti, non trovando parcheggio in un tempo ragionevole, possano assumere comportamenti negativi.
Molte persone sarebbero disposte a parcheggiare illegalmente o addirittura rinunciare all'attività da compiersi.
Lo stato dell'arte presenta numerosi lavori sul tema dello Smart Parking, proponendo idee sempre più innovative per limitare gli effetti negativi appena descritti.
In [4] si cerca di fornire all'utente una mappa dettagliata della quantità di parcheggi per strada. Questa può essere un'informazione utile per l'utente, il quale riesce quantomeno a farsi un'idea sulle strade 
più dense di parcheggi on-street.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{img/sensor-sp.png}
\caption{Sistema di Smart parking con sensori in-ground}
\end{figure}
I progetti mostrati in [5][10][11][14][15] si affidano a reti \textit{WSN} (Wireless Sensor Network), dove ogni sensore viene posizionato in prossimità del parcheggio (come mostrato in figura 1.2) ed instrada le proprie 
informazioni verso una struttura centralizzata.
L'efficienza di questi sistemi è molto alta, ma il costo per l'installazione e la manutenzione (come riportato anche nell'Introduzione) sono un limite per la loro diffusione.
Questo ha favorito lo sviluppo di sistemi Crowdsensing e Crowdsourcing, i quali permettono di ottenere risultati soddisfacenti partendo dal contributo degli utenti stessi.
I progetti in [2][4][7][8][9] forniscono all'utente, tramite l'ausilio di mappe, indicazioni riguardo la situazione parcheggi nelle vicinanze. 
Gli utenti che compiono un'attività di parcheggio, condividono i propri dati (ottenuti tramite sensori dello Smartphone o altro) con la comunità, evitando congestione del traffico stradale.
Questi lavori possono essere correlati all'attività di tesi presentata in questo documento, dove si cercherà di fornire agli utenti preziose informazioni sui parcheggi vicini, 
senza l'aiuto di architetture \textit{WSN} ed agenti centralizzati.
\subsection{Propagazione dell'informazione}
Una parte fondamentale all'interno dei sistemi Smart City e Smart Parking riguarda la propagazione dei dati tra i diversi utenti. Innanzitutto è bene distinguere la comunicazione secondo due paradigmi:
\begin{itemize}
\item \textit{centralizzata} : classica struttura Client-Server, dove una struttura centralizzata raccoglie tutti i dati derivanti da diverse fonti della Smart City e fornisce i risultati ai diversi client.
\item \textit{distribuita} : ogni dispositivo comunica con altri dispositivi cercando di propagare efficacemente l'informazione. L'assenza di una struttura centralizzata porta ogni nodo ad avere risultati 
parziali nel tempo, di conseguenza è necessario pensare ad efficaci metodi di propagazione in modo che tutti gli utenti restino allineati sulle informazioni prodotte dalla città.
\end{itemize}
Il secondo paradigma è quello che verrà utilizzato in questo lavoro di tesi, dove gli attori della rete saranno solamente dispositivi end-point. 
Risparmiando l'utilizzo di agenti centralizzati, si evitano importanti costi di installazione e gestione.
Il tema dello Smart Parking porta a considerare la Smart City come una rete veicolare distribuita ed in queste condizioni è normale pensare ad una comunicazione \textit{V2V} (Vehicle-To-Vehicle).
Il \textit{V2V} riguarda comunicazioni tra veicoli in movimento portanto alla creazione di reti spontanee, denominate \textit{VANETs} (Vehicular Ad-Hoc Networks).
Questi tipi di sistemi sono stati realizzati per propagare informazioni in maniera totalmente distribuita tra i vecoli, segnalando eventuali pericoli, incidenti, percorsi trafficati.
Ad oggi questo tipo di comunicazione non è disponibile per molte delle auto in commercio, trattandosi comunque di progetti costosi ed altamente innovativi.
Un altro modo di propagazione distribuita può avvenire invece tramite l'utilizzo di Smartphone, utilizzando il paradigma \textit{D2D} (Device-To-Device).
Il \textit{D2D} permette comunicazioni wireless tra device che sono nelle vicinanze. Questo approccio è quello che viene preso in considerazione nel lavoro di tesi, sfruttando i dispositivi utente per la 
propagazione di informazioni, relativa alla situazione parcheggi, all'interno della Smart City.
\part{Progettazione ed Implementazione}
\chapter{Progettazione}                %crea il capitolo
Il seguente capitolo ha lo scopo di illustrare in dettaglio il goal del progetto, le problematiche che vi stanno dietro e la fase di progettazione su cui è stato necessario soffermarsi, per la successiva realizzazione ed implementazione.
La mission, descrivendola in pochi concetti, è sostanzialmente quella di determinare quando un utente parcheggia o rilascia uno slot e disseminare queste informazioni in maniera totalmente distribuita, senza alcun appoggio di una struttura centralizzata.
Questo concetto diventa innovativo dal momento in cui non si passa dalla rete cellulare o da qualche gateway verso Internet per la comunicazione tra dispositivi, 
ma la comunicazione avverrà esclusivamente Device-To-Device, utilizzando tecnologie presenti nei più comuni device in commercio.
Quello che si vuole fornire all'utente sono delle probabilità di trovare parcheggio in una determinata zona della città, piuttosto che in altre.
Dettagli tecnologici ed implementativi saranno comunque discussi nel prossimo capitolo.
Di seguito verranno illustrate le principali strutture che compongono il sistema, descrivendone funzionalità, utilità ed integrazione con le restanti componenti.
\section{Scopo e problematiche}                 %crea la sezione
Come già accennato lo scopo principale è quello di propagare informazioni, tra dispositivi mobili, in maniera completamente distribuita, senza l'appoggio di agenti centralizzati.
Il device utente, tramite la componente di Activity Recognition presente nel software, rileva un evento di parcheggio (o rilascio) e ne tiene traccia, salvandolo in memoria locale.
Le informazioni sopradescritte saranno l'oggetto della comunicazione tra i device che potranno fare assunzioni su eventuali zone dense di parcheggi liberi.
Più gli utenti restano allineati e sincronizzati su questi dati, più restano aggiornati e consapevoli della situazione parcheggi nei dintorni.
Per scelta progettuale, la città viene divisa in celle (identificate con id univoci), permettendo così alla logica di disseminare informazioni relative alla cella in questione e a quelle adiacenti.
Un altro aspetto non meno importante di quelli già illustrati, è il fatto che il servizio deve funzionare in modo continuativo nel tempo e soprattutto in maniera totalmente autonoma.
Questo significa che l'utente, senza nessuna interazione con il device (per esempio mantenendolo in tasca), sincronizza comunque i propri dati con quelli di utenti circostanti.
La funzionalità appena descritta, per renderla robusta, ha richiesto una fase implementativa consistente, la quale verrà illustrata tecnicamente nel Cap.3.
\section{Scenario generale}                 %crea la sezione
Lo scenario che si va a considerare per l'utilizzo di un'applicazione di questo genere è una città metropolitana.
Questa può essere diversamente interpretata e suddivisa logicamente in una griglia composta da celle (quadranti), dove ognuna di queste viene identificata univocamente da una coppia di coordinate X e Y.
Queste coordinate sono considerate come indici matriciali che individuano una cella all'interno della matrice griglia della città. 
Si presuppone che il numero di parcheggi disponibili in una data cella sia un dato noto a priori, il quale comprende tutti gli slot disponibili nelle strade che sono raggruppate all'interno del 
quadrante considerato.
Si ricorda che si fa riferimento a parcheggi pubblici su strada e non a strutture private o a circuito chiuso.
\\Il device dell'utente, tramite l'implementazione presente nell'app, performando un evento di parcheggio o rilascio, riesce a recuperare la cella in cui risiede logicamente e registrerà nel proprio database locale 
che l'evento si è verificato in quello specifico quadrante.
Le assunzioni sulla probabile quantità, in percentuale, di parcheggi liberi vengono calcolate sulla granularità della cella.
\\In fase di progettazione, si è giunti alla conclusione che non è sufficiente scambiarsi il numero di parcheggi liberi/occupati derivanti da dati statistici, 
in quanto ogni utente potrebbe avere una parziale, ma diversa, visione dello scenario.
Da ciò deriva la necessità di sincronizzarsi su tutti gli eventi che sono successi recentemente in una determinata zona (cella) e quelle adiacenti.
Quando due peer cercheranno di sincronizzarsi verranno scambiate le informazioni relative alla cella corrente e quelle adiacenti.
In questo modo, si cerca di fornire all'utente, previsioni più precise sulle celle che sono nei pressi della posizione corrente del device.
Questo evita overhead nella comunicazione e sincronizzazione di entries che non sono utili all'utente.
Rimanendo nel discorso di overhead, è normale pensare che questo modello possa ``esplodere``, in quanto la mole di dati potrebbe diventare enorme con il passare del tempo.
Per evitare che questo succeda, viene controllata la dimensione del database locale, ed eventualmente eliminate le entries meno aggiornate.
Inoltre i peer possono effettuare sincronizzazioni soltanto dopo una certa threshold, espressa in secondi.
Questi concetti sono stati parametrizzati in fase di implementazione, quindi possono essere giustamente calibrati in base all'ambiente in cui si intende utilizzare l'app.

\section{Architettura generale}               %crea la sezione
L'architettura generale, analizzandola da un punto di vista esterno, prevede come unici attori i device utenti. Questi muovendosi all'interno dell'ambiente città restano in attesa di possibili sincronizzazioni.
Ogni dispositivo, che presenta il servizio di comunicazione e sincronizzazione attivo, può interpretare fondamentalmente due ruoli concettuali:
\begin{itemize}
 \item \textbf{ROLE ACCESS POINT}:
 \\Il device funge da Access Point, offrendo la possibilità a device presenti in prossimità di agganciarsi all'HotSpot esposto. Una volta che un Client si connette stabilmente ad esso avrà  l'opportunità di aprire 
 un canale di comunicazione e sincronizzare i propri dati con quelli del Access Point, denominato anche come Server.
 Inoltre l'Access Point notifica la propria presenza e informazioni utili attraverso la propagazione di un beacon.
 \item \textbf{ROLE CLIENT}:
 \\Se un device si accorge della presenza di un HotSpot nelle vicinanze, grazie al beacon sopracitato, può tentare di connettersi come Client all'Access Point. Qualora riesca ad agganciarsi in modo stabile 
 verranno avviati i canali di comunicazione, su cui effettuare una sincronizzazione tra i device Client e Server.
\end{itemize}
A questo punto la topologia della rete generale può essere vista come hub di hub, ovvero tante piccole star, dove grazie al movimento inerziale dei device si riuscirà ad ottenere una propagazione dell'informazione, 
interconnettendo appunto diverse star tra di loro, ad istanti di tempo differenti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/arch_general.png}
\caption[Rappresentazione dell'Architettura generale]{Rappresentazione dell'Architettura generale e della divisione in celle di una porzione di Bologna}
\end{figure}
\\Come si può comprendere dalla figura 2.1, i device muovendosi continuamente all'interno dello scenario (identificato in questo caso con la griglia città), formeranno continuamente nuove star, con attori sempre diversi.
Questo fattore è determinante per il processo di propagazione delle informazioni, in quanto dati presenti in una star, verranno sincronizzati, in istanti successivi, con star diverse.
L'analisi dello spreading delle informazioni, la sua efficacia ed accuratezza sono illustrate nel Cap.4, nel quale si cerca di capire se questo meccanismo è attuabile nella realtà.

\section{Architettura software}               %crea la sezione
Prima della fase di implementazione, è stato necessaria una fase di progettazione dell'architettura software. L'applicazione, per essere efficace nel meccanismo di 
spreading, necessita di numerosi componenti e soprattutto dell'interazione tra essi.
Nella figura 2.2 sono stati messi i componenti principali che concettualmente compongono l'architettura e come questi collaborano.
Di seguito vengono spiegati i compiti che ogni struttura deve compiere per la corretta esecuzione dell'applicativo sotware:
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/arch_soft.png}
\caption{Rappresentazione dell'Architettura software}
\end{figure}
\begin{itemize}
\item \textbf{Componente di Activity Recognition:}
\\Il componente di activity recognition si preoccupa di rilevare gli eventi di parcheggio e rilascio, che un determinato utente compie, col trascorrere del tempo. Questo è possibile tramite l'utilizzo dei sensori, 
i quali campionano periodicamente lo stato di accelerometro e giroscopio, mappandoli tramite un algoritmo decisionale in un'attività ben definita.
Questo processo, in realtà, si compone di due fase come training e recognition.
La prima è necessaria alla seconda e riguarda il campionamento dei dati sensore in una attività definita dall'utente di CAR o NO\_CAR. La seconda, invece, grazie ai campioni rilevati nella prima riuscirà a 
fare assunzione sul tipo di attività che l'utente sta svolgendo. L'algoritmo \textit{Random Forest} permette di classificare i dati grezzi in una precisa classe di movimento, tramite il massiccio utilizzo di alberi decisionali.
Quando il componente capisce che si è passato da uno stato CAR ad uno stato NO\_CAR, significa che l'utente ha parcheggiato l'autovettura, mentre, dualmente, se si passa da uno stato NO\_CAR a CAR, significa che 
l'utente ha rilasciato uno slot.
Quando una di queste due situazioni accade, si registra l'evento nel database locale.
L'implementazione di questa parte non è stata necessaria perchè è stato possibile usufruire interamente del sistema descritto in [2], dove si mostra come l'algoritmo di recognition riesca a raggiungere una precisione
di circa 90\%. 
\item \textbf{Componente Database locale:}
\\Il Database locale si preoccupa di raccogliere le informazioni sul device utente, le quali poi verranno processate per calcolare la probabilità di parcheggio in una determinata zona.
Le informazioni che vengono memorizzate sono illustrate più precisamente nella sezione 2.5.
\item \textbf{Componente Controller:}
\\Il Controller si preoccupa di scrivere, aggiornare e dare accesso alle informazioni presenti nel database locale. Inoltre, è stato pensato come semplice meccanismo di Object-Relational Mapping(ORM), 
per integrare al meglio le logiche ad oggetti con i dati presenti nel DBMS. 
\\Sostanzialmente, può essere interpretato come un oggetto Controller, del pattern MVC (Model-View-Controller), gestendo ed implementando le classi del Modello.
\item \textbf{Componente Frontend:}
\\Il frontend sono sostanzialmente le views che verranno mostrate all'utente, sul proprio device Android. Si è optato per un frontend semplice, per rendere utilizzabile l'app a qualsiasi tipo di utente, 
pur fornendo ad esso tutte le informazioni necessarie sullo stato dei parcheggi nelle vicinanze.
Nella sezione Screenshot è possibile prendere visione del layout grafico pensato per l'applicazione.
\item \textbf{ Componente Dissemination Service:}
\\Il componente di disseminazione delle informazioni è il cuore del progetto e l'elemento più articolato all'interno dell'architettura.
Questo è composto da diversi sottocomponenti, la maggior parte dei quali verranno illustrati con precisione nel capitolo di implementazione.
Il disseminatore è un servizio che gira in background e la logica è scandita da una FSM (Finite State Machine), dove in base allo stato in cui si trova verranno compiute azioni, piuttosto che altre.
Quando viene rilevata una nuova connessione ad un peer, il componente si preoccupa anche di gestire il corretto funzionamento della comunicazione, 
gestendo i canali di input e output verso gli altri device, nel range di comunicazione.
\end{itemize}
\subsection{Organizzazione dell'informazione}                 %crea la sezione
L'organizzazione dei city data è ovviamente una fase determinante del progetto.
Si è optato per la realizzazione di un database di tipo relazionale, composto principalmente da due tabelle, indipendenti l'una dall'altra.
\\La prima tabella, denominata, park\_events colleziona tutti gli eventi che gli utente compiono o ricevono in seguito a sincronizzazioni con altri utenti.
\\La seconda tabella synchronizations colleziona invece tutte le sincronizzazioni che hanno coinvolto il device in questione.
\\Come verrà illustrato nel Cap.4 relativo all'implementazione, gli strumenti utilizzati si baseranno completamente sullo standard SQL, i quali permetteranno una semplice gestione di 
query di filtraggio, creazione, modifica, cancellazione.
\\Entrando più in dettaglio nella composizione delle tabelle e degli attributi salvati, si mostra di seguito uno schema riassuntivo di ciò che viene messo a database:
\\\\ Tabella \textbf{\textit{park\_events}}:
\begin{itemize}
\item \underline{\textit{cell\_id}} : identificativo univoco della cella che la identifica all'interno della grid city. Informazione di tipo geografica.
\item \underline{\textit{event}} : evento che può essere limitatamente PARKED o RELEASED. Indica se l'entry fa riferimento ad una sosta o alla liberazione di un parcheggio.
\item \underline{\textit{timestamp}} : datetime che indica il momento in cui è stato performato l'evento in questione.
\item \underline{\textit{mac}} : identificativo univoco del device che ha performato l'evento di parcheggio o rilascio.
\end{itemize}
La PRIMARY KEY è composta da \underline{\textit{\textless timestamp, mac\textgreater}}. L'idea che vi sta dietro è quella che un utente può performare, in un dato istante, al più un unico 
evento di rilascio o parcheggio.
\\\\ Tabella \textbf{\textit{synchronizations}}:
\begin{itemize}
\item \underline{\textit{timestamp}} : datetime in cui è avvenuta la sincronizzazione.
\item \underline{\textit{mac}} : id univoco dell'altro device con cui è stata possibile la sincronizzazione.
\item \underline{\textit{ap\_role}} : booleano che indica se ero Access Point o meno al momento della sincronizzazione.
\end{itemize}

Questa tabella oltre a fini statistici,  è importante perché permette di evitare che due device si sincronizzino in continuazione.
Grazie all'attributo timestamp, si riesce a risalire all'ultima sincronizzazione che ha coinvolto il device e di conseguenza, è possibile settare una time threshold, sotto la quale 
non è possibile iniziare una nuova sincronizzazione.
Le logiche implementate a backend non permettono lo scambio di dati in istanti troppo vicini tra loro.
Questo meccanismo può esser visto come un minimo di salvaguardia da cicli continui o sovrapposizione di sincronizzazioni.

\subsection{Network State Machine}                 %crea la sezione
Come già accennato nell'architettura software, il processo di disseminazione delle informazioni è scandito da una macchina a stati finiti.
Si è deciso di approfondire questo componente per far comprendere meglio come vengono gestite le sincronizzazioni tra i device utente coinvolti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/nsm.png}
\caption{Network State Machine}
\end{figure}
\\Alla partenza del servizio, il device, non ha conoscenza dell'ambiente circostante, di conseguenza si rende disponibile come ruolo di Access Point ed entra nello stato STATE\_ACCESS\_POINT\_NO\_PEERS.
Quando si riesce a scoprire la presenza di altri peer, nei paraggi, si entra nello stato STATE\_ACCESS\_POINT\_PEERS.
A questo punto, il device, si mette all'ascolto di eventuali beacon di servizio, i quali potrebbero notificare la presenza di un preesistente Access Point.
\\Se questo non accade, il device rimane disponibile come ruolo di Access Point, notificando la propria presenza in beaconing e fornendo opportunità di sincronizzazioni ad eventuali client in arrivo (stato OPEN\_SERVER\_SOCKET).
\\Diversamente, se il device comprende la presenza di un Access Point già consolidato in zona, smette di svolgere il ruolo di HotSpot e comincia a comportarsi come Client, entrando, di conseguenza, 
in STATE\_CONNECTION.
Ora il device cerca di connettersi all'HotSpot, esposto grazie alla tecnologia WiFi Direct.
Se il processo porta ad una connessione stabile e ad un assegnazione di un indirizzo IP, verrà automaticamente aperto un canale di comunicazioni bidirezionali tra il Client e Server, iniziando così la fase 
di sincronizzazione (stato IN\_SYNC).
\\Come si può notare dallo schema in figura 2.3, da STATE\_CONNECTION vi è anche la possibilità di ripartire dall'inizio, nel caso in cui, il device non riesca a connettersi all'HotSpot 
entro una certa threshold.
Questo è stato fatto per evitare situazioni di stallo e cercare di ripartire da un punto più stabile.
Supponendo che la sincronizzazione sia andata a buon fine, si passa allo stato STATE\_SYNCED\_CONNECTED, il quale significa che la sincronizzazione è terminata ma si è ancora agganciati all'HotSpot del Server.
A questo punto, gli attori coinvolti, potrebbero allontanarsi a tal punto da rompere il legame creato e quindi il servizio ripartirebbe dallo stato iniziale di START.
Altrimenti, se gli utenti restano nelle vicinanze l'uno dell'altro, in modo tale da mantenere attiva la connessione, si dà l'opportunità al Client (dopo una certa threshold) di richiedere nuovamente una sincronizzazione.

\section{Probabilità di occupazione di una cella}                 %crea la sezione
Questa parte si preoccupa, man mano che le informazioni giungono nel database locale, di calcolare le probabilità di trovare parcheggio nelle celle della città.
Si ricorda che il dato che si fornisce all'utente è una probabilità e non un valore certo, così da dare indicazioni agli utenti, sulle zone, che statisticamente saranno meno congestionate.
Un'altra precisazione riguarda  il fatto che più utenti utilizzeranno l'applicazione, come supporto al parcheggio, e più dati verranno disseminati tra i device, aumentando progressivamente l'affidabilità 
delle probabilità fornite agli utenti.
Supponendo che il numero di slot totali in una generica cella i, identificato con la sigla N\ped{i}\ap{t}, sia noto a priori, lo si può interpretare anche come la somma tra numero di slot liberi, N\ped{i}\ap{f}, e 
numero di slot occupati N\ped{i}\ap{o}.
Questi ultimi due, possono essere ricavati a partire dagli eventi di parcheggio e rilascio, i quali sono presenti nel database locale citato in precedenza.
\\In particolare, il numero dei parcheggi occupati N\ped{i}\ap{o} può essere ricavato dalla differenza tra il numero di eventi parcheggio E\ped{i}\ap{p} ed il numero di eventi rilascio E\ped{i}\ap{r}.

$$N\ped{i}\ap{o} = E\ped{i}\ap{p} - E\ped{i}\ap{r} $$
\\A questo punto, conoscendo già il numero totale degli slot, è facile calcolare il tasso di occupazione di una determinata cella:
$$p\ped{i}\ap{o} = \df{N\ped{i}\ap{o}}{N\ped{i}\ap{t}}$$
\\Infine calcoliamo la probabilità di trovare parcheggio, servendosi del tasso di occupazione appena calcolato:
$$p\ped{i}\ap{f} = 1 - p\ped{i}\ap{o}$$
Quest'ultima sarà l'informazione, messa in percentuale, a cui l'utente avrà accesso una volta aperta l'applicazione. Verrà visualizzata la mappa della città suddivisa in griglia ed ogni quadrante sarà colorato in base alla 
probabilità di trovare parcheggio.
\\Nella sezione screenshot, figura 3.2, è possibile vedere quanto descritto.


\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Implementazione}
Come ribadito nel Cap. 2 l'obiettivo del progetto è quello di disseminare informazioni di Smart Parking in modalità Device-to-Device, senza l'ausilio di alcuna infrastruttura centralizzata. 
In base alle informazioni ricevute, si riuscirà dunque a fare assunzioni sulle quantità di parcheggi disponibile in determinate zone della città.
\\L'implementazione riguarda la realizzazione del processo di spreading nel Sistema Operativo Android, con l'ausilio della tecnologia \textit{WiFi Direct}.
Quest'ultima, presente a partire dalle librerie API 14 e device con Android 4.0 o superiori, permette la comunicazione one-to-one tra dispositivi utente.
\\Il capitolo seguente mostra i passi necessari alla realizzazione, dettagliando i componenti software realizzati partendo dalla base di progettazione, illustrata in sezione 2.4.
\section{Componente di disseminazione}
Il paragrafo illustra tutti gli attori principali che compongono il servizio di disseminazione delle informazioni. Ogni sottoparagrafo spiega le funzionalità
dei componenti e l'interazione con gli altri. Questa è la parte che, in fase di implementazione, ha richiesto maggior sforzo ed essendo il cuore del progetto, verrà maggiormente descritta, addentrandosi anche
nell'analisi del codice sorgente.
\subsection{Strategia di connessione tramite WiFi Direct}
La tecnologia \textit{WiFi Direct} rende possibile la creazione di cosiddetti \textit{P2P Groups}, i quali possono essere comparati ad infrastrutture WiFi. 
Il device che detiene le funzionalità di Access Point viene definito \textit{P2P Group Owner}, il quale può comunque mantenere attive connessioni cellulari (come ad esempio il 4G).
Per realizzare lo scopo del progetto il \textit{WiFi Direct} non è stato utilizzato in maniera tradizionale, bensì in modalità legacy.
\\Questo perchè, almeno nel primo incontro tra due device, la nascita della connessione necessità dell'interazione utente (come mostrato in figura 3.1).
\\Il nostro processo di comunicazione peer-to-peer non prevede però alcuna interazione dell'utente, in quanto i dispositivi devono scoprirsi e comunicare in maniera del tutto autonoma e trasparente.
\\Utilizzando la modalità legacy, un dispositivo crea un \textit{P2P Group} fungendo da Access Point, mentre gli altri lo percepiscono e si connettono ad esso come un normale HotSpot 802.11.
Questo dà la possibilità di connettere più client per Access Point, formando logicamente le topologie a stella, citate in sezione 2.3.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/popup.png}
\caption{Interazione utente per il consenso alla connessione}
\end{figure}
\subsection{Il servizio background}
Dato che il processo di comunicazione tra peer deve avvenire in maniera completamente trasparente all'utente, è stato necessario implementare un servizio che svolgesse 
il meccanismo di invio e ricezione dati, anche nel caso in cui l'applicazione venisse chiusa.
Un \textit{Service} è un componente Andorid, sprovvisto di interfaccia grafica, che si preoccupa di compiere procedure in background.
Questo componente è stato denominato \textit{NetworkAutoService}, ed estende appunto la classe \textit{Service} di Android. I metodi che gestiscono il servizio sono:
\begin{itemize}
 \item \textit{onCreate} : crea il servizio e lo notifica all'utente.
 \item \textit{onStartCommand} : metodo che inizia l'esecuzione vera e propria del servizio di disseminazione, in background. Qui, sostanzialmente, espone in beaconing la 
  possibilità di fungere da Access Point e si mette alla ricerca di preesistenti HotSpot nei paraggi. Queste funzionalità verranno descritte meglio in sezione 3.1.5 e 3.1.6.
  Si ricorda che l'attivazione del servizio è sancita dall'utente tramite la pressione di un pulstante da interfaccia grafica, come mostrano gli screenshot in figura 3.3.
 \item \textit{onDestroy} : Metodo che ferma il servizio e libera le strutture dati necessarie al processo di networking. L'utente richiama implicitamente questo metodo alla pressione del bottone stop del servizio, 
 come mostrano gli screenshot in figura 3.3.
 \item \textit{startCheckNetworkTimer} : metodo privato che inizializza un oggetto \textit{Timer} e lo schedula ogni 3s. Questi 3s possono essere interpretati logicamente come un time slot. 
 L'azione schedulata, prevede l'invio di un \textit{Intent}, in modo tale che il \textit{BroadcastReceiver} (definito nella sezione 3.1.8) lo possa catturare e controllare lo stato della Network State Machine (definita in sezione 2.4.2).
\end{itemize}
\subsection{Il NetworkController}
La classe \textit{NetworkController} si preoccupa di  gestire gli attori coinvolti nel processo di networking e disseminazione locale delle informazioni.
Questo oggetto è stato implementato seguendo le linee guida del pattern Singleton.
Questo pattern permette di creare una ed una sola istanza di una particolare classe, rendendola disponibile in ottica globale. 
Il concetto è quello di avere controllo, in ogni punto del progetto, sulle componenti fondamentali dell'architettura implementata.
Questo componente dà accesso agli oggetti delle classi \textit{NetworkBeaconPeerSearcher}, \textit{NetworkAccessPoint} e\textit{ NetworkConnection}.
Il primo si preoccupa di segnalare la presenza di beacon di servizio nelle vicinanze, il secondo governa eventuali funzionalità da Access Point del device, 
mentre il terzo implementa funzionalità client per connettersi ad HotSpot nei paraggi.
Inoltre registra in una variabile lo stato corrente della Network Machine State, la quale scandisce logicamente il processo di spreading.
Infine, espone metodi per la registrazione e rilascio del \textit{BroadcastReceiver}.
Di seguito vengono elencate i metodi principali che la classe espone:
\begin{itemize}
\item \textit{startNetworkAccessPoint} / \textit{stopNetworkAccessPoint} : metodi che decretano l'inizio, o la fine, del device come Access Point.
\item \textit{startNetworkConnection} / \textit{stopNetworkConnection} : metodi che cercano di connettersi, o scollegarsi, da un HotSpot.
\item \textit{startNetworkBeaconPeerSearcher} / \textit{stopNetworkBeaconPeerSearcher} : metodi che sanciscono l'inizio, o la fine, della ricerca di beacon nelle vicinanze.
\end{itemize}
\subsection{Connessione ad un Access Point}
La classe \textit{NetworkConnection} detiene la procedura necessaria per connettersi in maniera automatica ad un Access Point (presente nella lista ricavata dallo scan delle reti circostanti).
Questa classe viene utilizzata quando un device, tramite l'arrivo di un beacon, capisce che vi è un Access Point attivo e disponibile a soddisfare richieste di sincronizzazione.
Assumendo il ruolo di Client si cercherà di agganciarsi all'HotSpot individuato.
\\È necessario ricordare che, per effettuare queste procedure in maniera completamente automatica e trasparente all'utente, vi è la necessità di conoscere la passphrase per connettersi. 
Questa come vedremo in sezione 3.1.8, sarà ricavata dai beacon di servizio.
\\Di seguito viene mostrato il codice discusso:
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...

public class NetworkConnection {

  public static String TAG= "[DEBAPP]NetworkConnection";

  WifiManager wifiManager = null;
  WifiConfiguration wifiConfig = null;
  Context context = null;

  public NetworkConnection(Context Context, String SSIS, String passphrase) {
    Log.d(TAG, "New WiFiConnection @ AP SSID: " + SSIS + 
          " with psw: " + passphrase + " ..... ");
    this.context = Context;

    this.wifiManager = (WifiManager)this.context.getSystemService(
                                            this.context.WIFI_SERVICE);

    /* disable others */
    for (WifiConfiguration cnf:this.wifiManager.getConfiguredNetworks()) {
        this.wifiManager.disableNetwork(cnf.networkId);
    }

    /* set passphrase */
    this.wifiConfig = new WifiConfiguration();
    this.wifiConfig.SSID = String.format("\"%s\"", SSIS);
    this.wifiConfig.preSharedKey = String.format("\"%s\"", passphrase);

    /* try to reconnect with new config */
    int id = this.wifiManager.addNetwork(this.wifiConfig);
    this.wifiManager.enableNetwork(id, false);
    this.wifiManager.reconnect();
  }

  public void Stop(){
    Log.d(TAG, "Remove connection with AP!!");
    this.wifiManager.disconnect();
  }
}
\end{verbatim}  
\endgroup
\subsection{Esplorazione dell'ambiente circostante}
Il sistema ha la necessità di capire la situazione nell'ambiente esterno, scoprendo quanti e quali attori vi sono nelle vicinanze e comportarsi di conseguenza.
Tutto quello che verrà illustrato in questa sezione è stato implementato nella classe \textit{NetworkBeaconPeerSearcher}.
\subsubsection{Scoperta di peer}
La classe \textit{WiFiP2PManager} di Android, permette di gestire tramite chiamate API la connessione peer-to-peer tra device.
Molte di queste fungono da listener per gli eventi asincroni della rete, in modo tale da proporre determinate logiche al succedersi di determinati eventi.
Tramite il metodo \textit{discoverPeers} è possibile mettersi alla ricerca di eventuali device Android nell'ambiente circostante.
Per catturare le notifiche relative alla presenza di un device è stato necessario implementare un custom \textit{PeerListListener}, il quale grazie al metodo \textit{onPeersAvailable}
restituisce la lista dei peer presenti nei paraggi.
\subsubsection{Beacon di servizio}
Sempre nell'ambito peer-to-peer, la tecnologia Android, permette di pubblicizzare un servizio ad altri device prima di un'effettiva connessione tra i dispositivi.
La documentazione per developer di Android[21] specifica che questo meccanismo è stato fatto per individuare peer con determinati servizi.
I Bonjour service vengono creati grazie alla classe \textit{WifiP2pDnsSdServiceInfo}. 
Questa funzionalità è stata fondamentale per la realizzazione del progetto, in quanto permette di fare assunzioni prima di effettuare tentativi di connessione tra peer.
In un primo momento si è pensato di includere le informazioni relative agli eventi parcheggio direttamente all'interno di questi pacchetti, in quanto vi è la possibilità di inserire un tipo di dato 
\textit{Map\textless String, String\textgreater}.
Con questo tipo di meccanismo si sarebbe potuto attuare il cosiddetto piggybacking, inserendo il vero payload direttamente dentro a questi pacchetti di servizio.
Questa strategia, oltre ad abbassare notevolmente la complessità, avrebbe permesso di scambiare dati in broadcast tra device, senza che questi instaurassero una connessione.
L'implementazione però non è resa possibile a causa del basso contenuto, in termini di dimensione, che può essere inserito in questi beacon.
Lo standard consiglia di tenere questo contenuto sotto i 200 bytes e non è raccomandato superare i 1300 bytes[22 - sezione 6.2]. Provando empiricamente, si è potuto confermare la restrinzione appena citata.
Gli \textit{ArrayList} degli eventi che vogliamo sincronizzare hanno un contenuto maggiore del limite tecnologico imposto, per questo motivo si è dovuto virare sul meccanismo di Access Point e connessioni automatiche.
Questi pacchetti risultano comunque determinanti, in quanto incapsulano la stringa passphrase, necessaria ai client per connettersi in maniera automatica agli Access Point.
Tornando al progetto, è possibile scoprire questi servizi tramite il metodo \textit{startBeaconDiscovery}, il quale chiama a sua volta il metodo \textit{discoverServices} del \textit{WiFiP2PManager}.
Il listener, relativo alla scoperta di un servizio, riguarda la creazione di un oggetto \textit{DnsSdServiceResponseListener}, il quale implementando il metodo \textit{onDnsSdServiceAvailable}, fornisce in input tutte le 
informazioni necessario sul servizio appena scoperto (nome, tipo, device).
\subsubsection{Logiche di scoperta}
Nei precedenti due sottoparagrafi si è cercato di illustrare le funzionalità principali che si ritrovano nella classe \textit{NetworkBeaconPeerSearcher}, illustrando le funzioni API chiave utilizzate.
Ora si cercherà di spiegare la logica che è stato necessario implementare e come la scoperta di peer e servizi si interfacciano tra loro.
Quando un device scopre la presenza di almeno un peer attorno a lui, si mette immediatamente all'ascolto di eventuali servizi esposti da altri utenti.
Nel momento in cui si scoprisse un servizio idoneo (indicante la presenza di un Access Point) viene mandato 
un broadcast \textit{Intent} tale da notificare al \textit{BroadcastReceiver} di iniziare il processo di connessione all'HotSpot trovato.
La classe che implementa tutte queste funzionalità è abbastanza ampia, per questo si mostra il solo codice relativo ai listener citati nel paragrafo.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...
/* peer discover listener */
peerListListener = new WifiP2pManager.PeerListListener() {
  public void onPeersAvailable(WifiP2pDeviceList peers) {
    int nPeers = 0;
    for (WifiP2pDevice peer : peers.getDeviceList()) {
        nPeers++;
        Log.d(TAG, "PEER FOUND: " + peer.deviceName);
    }
    /* if there is someone, looking for D2DSP service */
    if(nPeers > 0){
        Log.d(TAG, "Search for a D2DSP service...");
        /* change NSM state */
        NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_ACCESS_POINT_PEERS;
        startBeaconDiscovery();
     } else { /* else search peers */
        Log.d(TAG, "Search for peers...");
        /* change NSM state */
        NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_ACCESS_POINT_NO_PEERS;
        startPeerDiscovery();
    }
  }
};

...

/* service discover listener */
serviceListener = new WifiP2pManager.DnsSdServiceResponseListener() {
  public void onDnsSdServiceAvailable(String serv, String type, WifiP2pDevice dev) {
    if (serviceType.startsWith(NetworkTestFragment.SERVICE_TYPE)) {
        if(broadcaster != null) {
            Log.d(TAG, "find a D2DSP beacon!");
            Intent intent = new Intent(Constants.INTENT_D2D_AP_FOUND);
            intent.putExtra(Constants.INTENT_D2D_AP_ACCESSDATA, serv);
            context.sendBroadcast(intent);
        }
    } else {
        Log.d(TAG, "This service is not for me!");
    }
    /* continue to search peers */
    startPeerDiscovery();
  }
};
...
\end{verbatim}  
\endgroup
\subsection{Funzionalità Access Point-like}
Le funzionalità necessarie ad un device per interpretare il ruolo di Access Point, sono definite nella classe \textit{NetworkAccessPoint}.
Queste, sostanzialmente, riguardano la creazione spontanea e autonoma di un \textit{WiFi Direct Group}, con la conseguente autoelezione a \textit{Group Owner}.
La classe implementa delle interfacce astratte Android, le quali permettono di catturare segnali relativi alla gestione del gruppo.
In particolare, l'interfaccia \textit{WifiP2pManager.GroupInfoListener} permette di essere notificati quando il gruppo è stato creato.
Questo è permesso dal metodo \textit{onGroupInfoAvailable}, dove in input vengono date tutte le informazioni necessarie sul gruppo appena formato.
A questo punto all'interno del metodo si richiama una procedura \textit{startBeaconAP} per creare ed esporre il servizio di notifica.
Oltre a questa operazione viene fatto partire il meccanismo per ricevere connessioni in input tramite Socket.
Come citato in precedenza (sezione 3.1.5), il beacon incorpora l'informazione di passphrase in modo tale che la connessione possa avvenire in maniera automatica tramite la classe \textit{NetworkConnection}.
Il codice sottostante mostra la creazione del gruppo tramite il metodo \textit{createGroup} e l'esposizione del servizio in merito alla notifica della corretta creazione della rete:
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...
/* Creation of WiFi Direct Group */
public void start() {

  p2p = (WifiP2pManager) NetworkController.getInstance().managerP2P;

  if (p2p == null) {
    Log.d(TAG, "Wi-Fi Direct NOT SUPPORTED, BYE!");
  } else {
    channel = NetworkController.getInstance().channel;
    /* WiFi Direct Group creation */
    p2p.createGroup(channel,new WifiP2pManager.ActionListener() {
      public void onSuccess() {
        Log.d(TAG, "WiFiDirect Group created!!");
      }
      public void onFailure(int reason) {
        Log.d(TAG, "Error in creation, error code " + reason);
      }
    });
  }
}

...

@Override
public void onGroupInfoAvailable(WifiP2pGroup group) {
  try {
    Log.d(TAG, "WiFi Direct Net is created, expose beacon service...");
    ...
    /* put passphrase in Bonjour instance service */
    startBeaconAP("D2DSP:" + group.getNetworkName() + ":" + 
                         group.getPassphrase() + ":" + netAddress);
    ...
    /* Start Socket Server for synchronizations with clients */
    if(NetworkController.getInstance().server == null) {
      NetworkController.getInstance().server = new Server();
    }
  } catch(Exception e) {
    Log.d(TAG, "onGroupInfoAvailable, error: " + e.toString());
  }
}

...

/* expose beacon that notifies clients the Access Point presence */
private void startBeaconAP(String instance) {
  Map<String, String> record = new HashMap<String, String>();
  record.put("D2DSP", "apactive");

  WifiP2pDnsSdServiceInfo service =
                     WifiP2pDnsSdServiceInfo.newInstance(
                        instance, Constants.SERVICE_TYPE, record);

  p2p.addLocalService(channel, service, 
                     new WifiP2pManager.ActionListener() {
    public void onSuccess() {
      Log.d(TAG, "Beacon is in air!");
    }
    public void onFailure(int reason) {
      Log.d(TAG, "Adding local service failed, error code " + reason);
    }
  });
}
...
\end{verbatim}  
\endgroup
\subsection{Canali di comunicazione}
Una volta che l'Access Point crea la rete ed altri peer riescono a connettersi, identificandosi con un indirizzo IP, si può passare all'apertura dei canali di comunicazione ed alla sincronizzazione degli 
eventi di parcheggio/rilascio.
I canali di comunicazione si basano su \textit{Socket} serializzate, permettendo di inviare e ricevere, con un semplice casting, direttamente degli \textit{ArrayList\textless ParkEvent\textgreater}.
L'Access Point, appena notificato dell'avvenuta creazione del gruppo, richiama la creazione di un oggetto della classe \textit{Server}, il quale istanzia una \textit{ServerSocket}, mettendosi in ascolto di eventuali richieste,
con il metodo \textit{accept()}.
I client invece, quando notificati dal \textit{BroadcastReceiver} dell'avvenuta connessione all'HotSpot, creano un oggetto \textit{Socket} con IP e idonea.
Ora che il canale di comunicazione bidirezionale è stato messo in piedi, l'Access Point invierà il proprio\textit{ ArrayList} nell'\textit{ObjectOutputStream}, grazie al metodo \textit{writeObject}. 
Il Client coinvolto, vedendosi arrivare le informazioni nel canale \textit{ObjectInputStream}, le memorizza in una variabile ed invia le proprie, ripetendo il procedimento sopradescritto a parti inverse.
Una volta chiuso il canale, viene fatto il merge delle entries ricevute con quelle già presenti in memoria.
Si precisa che tutti i meccanismi descritti vengono gestiti tramite \textit{Thread}, in modo tale che il processo di sincronizzazione non risulti bloccante.
Anche le classi \textit{Client} e \textit{Server} sono corpose dal punto di vista del codice, di conseguenza si illustra il codice dei passi salienti.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}

### CLIENT SIDE ###
public class Client implements Runnable {
  ...
  public void run() {
    try {
      ...
      Socket socket = new Socket(serverAddr, Constants.PORT);
      ArrayList<ParkEvent> parkEventsFromOther;

      while (true) {
        ...
        try {
          ObjectInputStream objectInStream = 
              new ObjectInputStream(socket.getInputStream());
          /* get data from Socket channel */
          parkEventsFromOther = 
              (ArrayList<ParkEvent>) objectInStream.readObject();
          ...
          break;
        } catch (Exception e) {
        }
      }
      ...
      while(run) {
        try {
         ObjectOutputStream objectOutStream = 
             new ObjectOutputStream(socket.getOutputStream());
         /* write data in Socket channel */
         objectOutStream.writeObject(Controller.getInstance().parkEvents);
         break;
        } catch (IOException e) {
         run = false;
        }
      }
     socket.close();
     /* merge new entries */
     Controller.getInstance().mergeEntries(parkEventsFromOther);
     /* register sync */
     Controller.getInstance().insertSynchronizationOnSQLiteDB(
                        false, macWithSync);
     /* change state in NSM */
     NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_SYNCED_CONNECTED;
    } catch (Exception e) {
    }
  }
}

...

### SERVER SIDE ###
...
/* Thread that attend for client socket requests */
private class SocketServerThread extends Thread {

  @Override
  public void run() {
    try {
      /* create ServerSocket using specified port */
      serverSocket = new ServerSocket(Constants.PORT);
      while (true) {
        Socket socket = serverSocket.accept();
        /* thread for socket sync with client - logic of 
         socketServerReplyThread are same of Client Side */
        SocketServerReplyThread socketServerReplyThread = 
             new SocketServerReplyThread(socket);
        socketServerReplyThread.run();
      }
    } catch (IOException e) {
    }
  }
}
...
\end{verbatim}  
\endgroup
\subsection{L'ascoltatore BroadcastReceiverManagement}
Un componente fondamentale, a livello implementativo, è senza dubbio il \textit{BroadcastReceiverManagement}. Questo estende la classe Android \textit{BroacastReceiver} ed è in grado di 
ricevere avvisi sia dall'app stessa, che da componenti esterni di sistema.
Per avvisi si intendono \textit{Intent}, i quali vengono catturati dal metodo \textit{onReceive} della classe.
Questi oggetti possono tranquillamente lavorare in background e ricevere aggiornamenti anche se l'applicazione è chiusa.
Qui vengono prese tutte le decisioni riguardanti il networking, in base ai segnali ricevuti automaticamente in input.
La classe può essere interpretata anche come un decisore, che in base al succedersi di determinati eventi, compie precise azioni.
Di seguito vengono illustrati i comportamenti fondamentali, in base a determinati Intent in input. Le istruzioni condizionali citate sono tutte all'interno del metodo \textit{onReceive}.
\begin{itemize}
\item \textbf{Tentativi di connessione :}
\\All'arrivo di un custom Intent INTENT\_D2D\_AP\_FOUND, il sistema capisce che è stato scoperto un Access Point attivo nelle vicinanze e cerca di connettersi ad esso, 
utilizzando la passphrase ricavata dal beacon di Bonjour.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...
if (Constants.INTENT_D2D_AP_FOUND.equals(action)) {
  /* get beacon data */
  String serv = intent.getStringExtra(Constants.INTENT_D2D_AP_ACCESSDATA);
  String[] separated = serv.split(":");
  
  if(NetworkController.getInstance().networkConnection == null) {
  
    /* stop my Access Point functionalities */
    NetworkController.getInstance().stopNetworkAccessPoint();
    NetworkController.getInstance().stopNetworkBeaconPeerSearcher();
    
    /* Now I'm a simple Client */
    String networkSSID = separated[1];
    String networkPass = separated[2];  /* passprhase from beacon */
    String ipAddress   = separated[3];

    Log.d(TAG, "start new connection @ " + networkSSID);
    /* start connection mechanism */
    NetworkController.getInstance().networkConnection = 
        new NetworkConnection(ctx, networkSSID,networkPass);
    /* change state of NSM */
    NetworkController.getInstance().networkStateMachine = 
        Constants.STATE_CONNECTION;
  }
}
...
\end{verbatim}  
\endgroup

\item \textbf{Gestione dello stato di connessione :}
\\L'Intent \textit{WifiManager.NETWORK\_STATE\_CHANGED\_ACTION} decreta un cambiamento di stato della connessione WiFi del device. Se è avvenuta una 
disconnessione il device torna disponibile ad interpretare il ruolo di Access Point, mentre se è decretata la connessione ad un HotSpot inizierà il procedimento di sincronizzazione, lato Client.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...
if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(action)) {
  NetworkInfo info = 
      intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
  if(info != null) {
    if (info.isConnected()) {
      ...
     }else {
       /* connection with AP is lost */
       if(this.connetionState.equals(Constants.CONN_STATE_CONNECTED)){
         Log.d(TAG, "WiFi DIS-Connecting...");
         this.connetionState = Constants.CONN_STATE_DISCONNECTED;
       }
     }
    if(this.connetionState.equals(Constants.CONN_STATE_DISCONNECTED)){
      /* start access point functionalities */
      ...
    }
  }
  WifiInfo wiffo = 
      intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
  if(wiffo != null){/* I'm now connected! */
    /* open client socket channel*/
    this.runThreadSync(context);
  }
}
...
\end{verbatim}  
\endgroup

\item \textbf{Sincronizzazioni successive :}
\\Come ribadito in fase di progettazione, se un Client mantiene la propria connessione attiva con l'Access Point per un certo periodo 
ha la possibilità di effettuare un successivo scambio dati, dopo una certa threshold.
Il componente quindi controlla periodicamente lo stato della Network State Machine e se il device continua a trovarsi nello stato STATE\_SYNCED\_CONNECTED anche dopo la soglia stabilita, può effettuare 
un'ulteriore comunicazione con l'HotSport Server.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}  
...
if(Constants.INTENT_D2D_CHECK_MACHINE_STATE.equals(action)) {
...
  /* check for threshold */
  boolean isPossibleSync = Controller.getInstance().isPossibleSync();
  String state = NetworkController.getInstance().networkStateMachine;
  if((state.equals(Constants.STATE_SYNCED_CONNECTED))&&(isPossibleSync)) {
      ...
      /* re-synchronized client side */
      this.runThreadSync(context);
  }
...
}
...
\end{verbatim}  
\endgroup
\end{itemize}
\section{Gestione dell'informazione}
Ogni device Android deve essere in grado di registrare tutte le informazioni sincronizzate nella propria memoria locale. Le informazioni vengono organizzate in un database di tipo relazionale
basandosi sullo standard SQL e mappate in oggetti Java, in modo da semplificarne la gestione.
\subsection{Il Modello}
Il modello si compone di due entità, definite come \textit{Synchronization} e \textit{ParkEvent}. 
Gli attributi che compongono queste due classi sono i medesimi definiti in fase di progettazione (sezione 2.4.1) ed i metodi 
sono i tradizionali getter e setter, i quali permettono di leggere informazioni e settare attributi delle istanze Java in questione.
All'interno dell'architettura, queste istanze, vengono gestite e rese accessibili dal \textit{Controller} tramite degli \textit{ArrayList\textless *\textgreater}.
\subsection{Il database SQLite}
Salvare le informazioni dei parcheggi in maniera strutturata è sembrato la soluzione migliore fin dalla progettazione. Nei sistemi mobili Android è possibile lavorare con basi di dati 
tramite l'utilizzo di \textit{SQLite}. Si tratta di una serie di API, presenti nel package \textit{android.database.sqlite}, che permettono di gestire un file come un database transazionale a tutti gli effetti.
All'avvio dell'applicazione viene istanziato un oggetto \textit{CustomSQLiteHelper} (estensione della classe \textit{SQLiteOpenHelper}) che controlla se esiste un database SQLite e ne apre la connessione.
Se è la prima volta che l'utente avvia l'applicazione, dopo l'installazione, viene automaticamente creato il database con le tabelle \textit{synchronizations} e \textit{park\_events}.
La classe che effettua le query sql e che viene contatta dal \textit{Controller} per recuperare informazione dal database è \textit{SQLiteDBManager}.
I metodi che fornisce questa classe sono i necessari per operazioni CRUD(Create Read Update Delete) su una base di dati. La chiamata \textit{rawQuery} dell'oggetto \textit{SQLiteDatabase} permette di 
effettuare del codice SQL puro, in modo da facilitare le query più particolari. Di seguito viene mostrato il codice di alcune funzionalità.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}
/* INSERT a new park event in SQLite DB, return the unique id of new entry */
public boolean insert(int cellId, String event, String timestamp, String mac) {
  ContentValues values = new ContentValues();
  values.put(ParkEventEntrySQLiteDb.COLUMN_PARK_CELL_ID, cellId);
  values.put(ParkEventEntrySQLiteDb.COLUMN_PARK_EVENT, event);
  values.put(ParkEventEntrySQLiteDb.COLUMN_PARK_TIMESTAMP, timestamp);
  values.put(ParkEventEntrySQLiteDb.COLUMN_PARK_MAC, mac);

  long idRow = this.db.insert(ParkEventEntrySQLiteDb.TABLE_NAME, null, values);
  /* if entity already exists -> return FALSE */
  if(idRow < 0)
    return false;
  
  return true;
}

...

/* Get all Synchronizations from DB, return the ArrayList of these entities */
public ArrayList<Synchronization> getSyncByTimeRole(int apRole, String timeLimit) {

  ArrayList<Synchronization> toReturn = new ArrayList<Synchronization>();
  Cursor c = null;

  /* filter on time */
  if((apRole == -1)&&(!timeLimit.equals("ALL"))) {
    c = this.db.rawQuery(
      "SELECT * " + 
      "FROM " + SyncSQLiteDb.TABLE_NAME + " " + 
      "WHERE " + SyncSQLiteDb.COLUMN_SYNC_TIMESTAMP + " >= '" + timeLimit + "' " + 
      "ORDER BY " + SyncSQLiteDb.COLUMN_SYNC_TIMESTAMP + " DESC;", null
    );
  } else if((apRole != -1)&&(!timeLimit.equals("ALL"))) {
    /* filter on time and role - same logic */
  } else if((apRole == -1)&&(timeLimit.equals("ALL"))) {
    /* all entities - same logic  */
  } else if((apRole != -1)&&(timeLimit.equals("ALL"))) {
    /* filter on role - same logic */
  }

  /* return data in ArrayList of entities Synchronization */
  if(c.moveToFirst()) {
    do{
      int id = c.getInt(0);
      String timestamp = c.getString(1);
      String mac = c.getString(2);
      boolean roleAp = c.getInt(3) == 1;

      Synchronization sy = new Synchronization(timestamp, mac, roleAp);
      toReturn.add(sy);
    }while(c.moveToNext());
  }

  c.close();
  return toReturn;
}
\end{verbatim}  
\endgroup

\subsection{Il Controller}
L'oggetto \textit{Controller} si avvicina concettualmente al \textit{NetworkController}, illustrato in 3.1.3. Implementato anch'esso con il pattern Singleton, ha l'obiettivo di fornire agli altri componenti dell'
architettura le informazioni presenti nel database \textit{SQLite}. Quando si deve effettuare una query sulla base di dati, non si crea un oggetto \textit{SQLiteDBManager} ma si contatta direttamente il \textit{Controller}, 
il quale fornirà la risposta. 
Oltre a fungere da interfaccia verso il database, implementa anche altri metodi utili:
\begin{itemize}
\item \textit{isMyServiceRunning(Class\textless ?\textgreater class, Context ctx)} : metodo che controlla se un determinato servizio background è attivo.
\item \textit{mergeEntries(ArrayList\textless ParkEvent\textgreater pe)} : metodo che unisce le nuove entries in input con quelle preesistenti nella memoria locale.
\item \textit{getMacAddr()} : metodo che ritorna l'indirizzo MAC del device.
\item \textit{isPossibleSync()} : metodo che sancisce se è possibile effettuare una sincronizzazione. I client, prima di effettuare una sincronizzazione con l'Access Point, controllano che sia passata
                                  una certa threshold dall'ultimo scambio dati.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}    
/* Return if is possible a synchronization */
public boolean isPossibleSync() {
  /* get last sync time */
  String lastSyncStr = dbManager.selectLastSyncTimestamp();
  /* if is first time */
  if(lastSyncStr.equals(""))
    return true;
  
  SimpleDateFormat format = 
          new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault());
  Date date = null;
  ...
  date = format.parse(lastSyncStr);
  ...
  if(date != null) {
    Date now = new Date();
    /* get difference from now and last sync in seconds */
    long diff = (now.getTime() - date.getTime())/1000;
    /* check threshold in seconds */
    if(diff < Constants.TIME_FOR_NEXT_SYNC)
      return false;
    }
  return true;
}
\end{verbatim}  
\endgroup
\end{itemize}
\subsection{L'informazione utente}
La classe \textit{ProbabilityPark} tramite il metodo \textit{getProbabilityToParkByCell} implementa i calcoli relativi alla probabilità di trovare parcheggio in una determinata cella della città. Sostanzialmente
si tratta della traduzione in codice sorgente di quanto detto in sezione 2.5.
\begingroup
\fontsize{9pt}{8pt}
\begin{verbatim}
/* return a probability in % to find a vacant slot in a particular cell */
public int getProbabilityToParkByCell(int cell, int totSlot) {
  /* count of parked events in cell */
  int eventParked = Controller.getInstance().getCountParkedByCell(cell);
  /* count of released events in cell */
  int eventReleased = Controller.getInstance().getCountReleasedByCell(cell);
  /* occupied slots */
  int occupiedSlots = eventParked - eventReleased;
  float occupiedLevel = (float)occupiedSlots / totSlot;
  /* % probability to find free slot */
  float probabilityToPark = (1 - occupiedLevel) * 100;

  return (int)probabilityToPark;
}
\end{verbatim}  
\endgroup
\section{Interfaccia grafica}
L'interfaccia grafica è gestita da un'estensione della classe Android \\\textit{AppCompactActivity}. L'utente tramite il movimento di swipe laterale ha la possibilità di spostarsi da una schermata all'altra.
La \textit{MainActivity} utilizza un \textit{FragmentPagerAdapter} per catturare l'evento di swipe e mostrare il \textit{Fragment} corretto.
Ogni schermata viene gestita da un'estensione della classe \textit{Fragment}, fornendo all'utente una determinata interfaccia grafica in base ai file \textit{xml} di layout che vengono settati nel metodo \textit{onCreateView}.
L'applicazione è composta da 5 schermate:
\begin{itemize}
\item \textit{MapFragment} : schermata che mostra la città divisa in celle, colorate in base alla probabilità di occupazione. La pressione di una cella fornisce un \textit{Toast} indicante la probabilità in numero. La figura 3.2 
                              mostra lo screenshot della schermata.
\item \textit{DisseminationFragment} : schermata in cui si può attivare/disattivare il servizio di disseminazione tramite \textit{WiFi Direct}. Inoltre si forniscono all'utente informazioni sullo 
                              stato in cui si trova. Le figure 3.3 e 3.4 mostrano lo screenshot della schermata.
\item \textit{RecognitionFragment} : schermata in cui si può attivare/disattivare le fasi di training e recognition della mobilità. Se la fase di recognition è attiva viene mostrata la predizione corrente. 
                              La figura 3.5 mostra lo screenshot della schermata.
\item \textit{SyncListFragment} : schermata in cui viene mostrato all'utente la lista delle ultime sincronizzazione. È possibile filtrare per tempo e ruolo (se il device fungeva da Access Point o no al momento della sincronizzazione).
                              La figura 3.6 mostra lo screenshot della schermata.
\item \textit{ParkEventListFragment} : schermata in cui viene mostrato all'utente la lista degli ultimi eventi di parcheggio. È possibile filtrare per cella e tipo (parcheggio o rilascio).
                              La figura 3.6 mostra lo screenshot della schermata.
\end{itemize}
\newpage
\section{Screenshot}
Di seguito sono mostrati gli screenshot dell'applicazione D2DSmartParking:
\begin{figure}[!h]
\centering
\includegraphics[scale=0.2]{img/screenshot/map.jpg}
\caption[Screenshot della mappa di Bologna con probabilità di parcheggio]{Mappa del centro di Bologna divisa in celle, ognuna colorata con la relativa probabilità di trovare parcheggio}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_ap_no_peers.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/state_ap_peers.jpg}
\caption[Screenshot della schermata Network State Machine(1)]{Servizio di disseminazione attivo negli stati STATE\_ACCESS\_POINT\_NO\_PEERS e STATE\_ACCESS\_POINT\_PEERS}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_conn.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/state_in_sync.jpg}
\caption[Screenshot della schermata Network State Machine(2)]{Servizio di disseminazione attivo negli stati STATE\_CONNECTION e STATE\_IN\_SYNC}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_synced_connected.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/activity_recogn.jpg}
\caption[Screenshot della schermata di Activity Recognition]{Servizio di disseminazione attivo negli stati STATE\_SYNCED\_CONNECTED e schermata del componente di Activity Recognition}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/last_sync.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/park_event_list.jpg}
\caption[Screenshot delle liste di sincronizzazioni ed eventi parcheggio]{Schermate che mostrano all'utente le ultime sincronizzazioni effettuate e gli eventi parcheggio, con possibilità di filtro}
\end{figure}
\clearpage{\pagestyle{empty}\cleardoublepage}
\part{Valutazione}
\chapter{Valutazione}
Quest'ultima fase riguarda la valutazione del processo di disseminazione delle informazioni, grazie alla quale riusciamo a comprendere come le informazioni si propagano all'interno del mondo che si va a considerare.
\\È importante comprendere che non si andrà a valutare la precisione delle probabilità di parcheggi liberi, bensì si andrà a verificare come gli utenti restano allineati sulle informazioni prodotte e propagate dagli agenti dello scenario.
Infatti l'importante è che l'utente riesca a sincronizzarsi efficacemente con gli altri attori circostanti, in maniera tale da restare aggiornato, durante il movimento, sulla cella corrente e su quelle adiacenti.
\section{Strumenti}
Ovviamente non è possibile testare lo spreading delle informazioni in un ambiente reale, di conseguenza ci si affida ad un simulatore ad eventi discreti.
In ambito accademico lo strumento più efficace ed utilizzato per fare simulazione è senza dubbio OMNeT++.
Questo prodotto, disponibile in open source dal 2003, viene utilizzato in fase di progettazione, ricerca, testing e analisi di protocolli di rete, architetture software e hardware.
L'ambiente di sviluppo è un surrogato di Eclipse ed il linguaggio principale è il C++.
\\La logica del simulatore si basa sul concetto fondamentale di Modulo, i quali possono essere aggregati e customizzati a seconda delle proprie esigenze.
In particolare, per la valutazione del progetto e dell'architettura pensata è stato necessario sviluppare un componente SmartParking che riproponesse la logica pensata in fase di progettazione ed 
implementata conseguentemente.
Come verrà illustrato in sezione 4.2, sono stati parametrizzati gli aspetti che influenzano maggiormente lo spreading dell'informazione, in modo tale da comprendere le differenze al variare delle condizioni.
\\L'utilizzo di OMNeT viene integrato dall'apporto di SUMO e di Veins.
Il primo è un simulatore di mobilità urbana, anch'esso ottenibile in open source, che si preoccupa di emulare reti stradali, anche di grosse dimensioni.
Tutte le configurazioni necessarie per il corretto funzionamento di questo, definite in file xml, riguardano la definizione delle strade, delle costruzioni presenti nell'ambiente e delle macchine (di cui, 
per ognuna, viene specificato il tempo di partenza ed il percorso da effettuare).
La gestione di questi file risulta complicata quando si vanno a simulare intere città, in quanto la mole di dati diventa importante.
Veins è un framework open source, scritto anch'esso in C++, che fornisce una grossa quantità di moduli preimplementati, per la simulazione di protocolli wireless in ambito veicolare.
Inoltre vengono fornite API per interfacciarsi a TraCi, un server di SUMO che permette l'interazione tra i diversi simulatori.
\\I risultati delle simulazioni possono essere visualizzati direttamente da un apposita interfaccia grafica fornita da OMNeT ma possono anche essere esportati in vari formati. Si è scelto di esportare i risultati
in formato CSV, per poi analizzarli tramite degli script PHP.
\section{Modellazione}
La città presa in considerazione per l'analisi simulata del processo di disseminazione locale è Bologna.
In realtà, viene presa in considerazione soltanto una porzione di questa, più precisamente la zona nord-est del centro storico fino ad arrivare in zona Bologna fiere, fuori dall'anello del centro.
Quantificandola, l'area appare come un rettangolo di 2.5 km per 1.5 km, per un totale di 3.75 km\ap{2}.
Comprendendo le strutture universitarie e la stazione dei treni, si tratta di una zona abbastanza movimentata e del tutto idonea al testing dell'architettura implementata.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/sumo-bolo.png}
\caption[Interfaccia grafica SUMO di Bologna]{Interfaccia grafica di SUMO che mostra la porzione di Bologna per la simulazione}
\end{figure}
\\La struttura implementata permette di parametrizzare determinate metriche in fase di configurazione, le quali vengono citate in elenco:
\begin{itemize}
\item \underline{\textit{range}} : quando i due dispositivi risiedono l'uno nel range trasmissivo dell'altro la comunicazione avrà esito positivo. Misura espressa in metri.
\item \underline{\textit{min\_latency}} : latenza minima che un utente aspetta per effettuare una sincronizzazione. Misura espressa in secondi.
\item \underline{\textit{max\_latency}} : latenza massima che un utente può verificare prima che avvenga una sincronizzazione o un fallimento. Misura espressa in secondi.
\item \underline{\textit{sensor\_accuracy}} : accuratezza dei device Android nel performare l'evento di activity recognition rilascio o parcheggio. Misura espressa in percentuale da 0 a 1, compresi.
\item \underline{\textit{synchronization\_time}} : tempo minimo per cui un utente deve aspettare prima di poter ri-sincronizzarsi. Misura espressa in secondi.
\item \underline{\textit{cell\_size}} : lunghezza del lato di una cella, espresso in metri.
\end{itemize}
La logica progettata per la simulazione è una versione semplificata di quella implementata nell'applicazione Android ma rappresenta comunque fedelmente il modello, in modo che i risultati 
ottenuti possano essere ritenuti affidabili.
I dispositivi si possono sincronizzare continuamente nel tempo ma, per problemi di overhead già citati, tra due scambi di dati deve passare una certa threshold, rappresentata nel modello dal parametro 
\textit{synchronization\_time}.
\\I parametri di \textit{min\_latency} e \textit{max\_latency} rappresentano il tempo che gli \\Access Point e i Client ci mettono per identificare il loro ruolo, scoprire peer, rilevare beacon e connettersi ad un \textit{WiFiDirect Group}.
\section{Obiettivi di simulazione}
In fase di simulazione, si vuole dimostrare che il movimento inerziale degli utenti e la strategia di disseminazione locale, permettono di restare sincronizzati sugli eventi che effettivamente accadono.
In particolare si cercherà di analizzare l'accuratezza dei dati presenti nei database locali ai device utente, rispetto a ciò che è accaduto realmente.
\\Per definire meglio il concetto dell'accuratezza, si prenda di riferimento una cella \textit{i} dove, nel lasso di tempo \textit{t}, sono stati performati 100 eventi parcheggio o rilascio.
A questo punto, in un determinato istante \textit{t\ped{i}}, se il device ha nella propria conoscenza locale 10 eventi dei 100 totali, avrà un'accuratezza del 10\%, se ne ha 50 avrà accuratezza del 50\% e così 
fino al limite superiore del 100\%, il quale può essere raggiunto solo da una struttura di tipo centralizzata.
L'accuratezza, appena descritta, verrà calcolata e registrata nel corso del tempo per comprendere il relativo andamento, col trascorrere dei secondi.
Inoltre verrà stabilita l'accuratezza in relazione alla distanza, per capire il grado di allineamento non solo sulle celle strettamente adiacenti, ma anche su quelle progressivamente più lontane.
Infine verrà presa in considerazione l'accuratezza media dopo 1800 secondi in base al numero di veicoli presenti nella porzione di Bologna considerata.
\\Tutte queste misurazioni verranno comparate simulando diverse tecnologie, in modo tale da capire dove si colloca l'implementazione tramite WiFi Direct.
\section{Configurazioni e run}
Si vogliono comparare le metriche sopradescritte, simulando l'architettura con l'utilizzo di tre tecnologie differenti quali \textit{VANET V2V}, \textit{WiFi Direct} e \textit{Bluetooth}.
Il tempo per ogni run di simulazione è stato settato a 1800 simsec (mezzora simulata) e per ogni tecnologia si considera lo scenario target con 3000 veicoli.
Il numero di veicoli fa riferimento a rilevamenti reali della porzione di Bologna considerata, in orari centrali della giornata. Per ottenere una stima dell'accuratezza media, dopo 1800 secondi,
in base al numero di veicoli è stato necessario effettuare simulazioni riducendo le autovetture anche a 1500 e 500.
L'accuratezza dei sensori è stata settata per tutte le simulazioni a 90\%. Questo deriva dello studio in [2], dove viene stimata l'accuratezza del componente di activity recognition presente nell'architettura.
\\Per ottenere un'analisi statistica che abbia un senso, si effettuano 10 run indipendenti per ogni tecnologia e numero di veicoli, per un totale di 90 run indipendenti.
I risultati saranno frutto delle medie dei vari run con la stessa configurazione.
\begin{table}[h]                        %ambiente tabella
                                        %(serve per avere la legenda)
\begin{center}                          %centra nella pagina la tabella
\begin{tabular}{ |p{4.8cm}||p{2cm}||p{2.5cm}||p{2.5cm}|  }
 \hline
 \multicolumn{4}{|c|}{\textbf{Simulation parameters}} \\
 \hline
 \textbf{technology}&V2V&WiFi Direct&Bluetooth\\
 \textbf{range(m)}&500&100&20\\
 \textbf{min\_latency(s)}&0&2&5\\
 \textbf{max\_latency(s)}&0&10&15\\
 \textbf{sensor\_accuracy(\%)}&0.90&0.90&0.90\\
 \textbf{synchronization\_time(s)}&20&20&20\\
 \textbf{cell\_size(m)}&250&250&250\\
 \textbf{sim time(simsec)}&1800&1800&1800\\
 \hline
\end{tabular}
\caption{Parametri di simulazione}\label{tab:uno}
\end{center}
\end{table}
\subsubsection{VANET V2V}
Per simulare la tecnologia presente nei sistemi \textit{V2V}, basato sull'\textit{802.11p}, si setta il \textit{range} di comunicazione sui 500m. Recenti studi dimostrano come questi sistemi possano, talvolta, 
manetere le connessioni anche a 1000m[28],
ma la distanza settata appare più idonea per testare la tecnologia.
I parametri di \textit{min\_latency} e \textit{max\_latency} sono azzerati in quanto la logica descritta in fase di progettazione ed implementata sull'app Android, su questi sistemi, non ha senso di esistere.
I canali di comunicazione V2V non necessitano di un meccanismo di esposizione dell'HotSpot e connessione a questo da parte dei client.
\subsubsection{WiFi Direct}
Questa configurazione rispecchia l'architettura progettata ed implementata sull'applicazione Android. 
La documentazione ufficiale dello standard \textit{WiFi Direct} dice che il range di comunicazione potrebbe raggiungere
i 200m[20]. In realtà 100m sembra un'assunzione più realistica per garantire la maggior parte delle connessioni.
La latenza di apertura dei canali di comunicazione viene settata dai 2 ai 10 secondi.
\subsubsection{Bluetooth}
La terza tecnologia che si vuole considerare è il \textit{Bluetooth}, il quale ha un range di comunicazione sui 20m ed una latenza di connessione che va dai 5 ai 15 secondi.
Quest'ultimi parametri possono essere visti come un approccio ottimistico, in quanto il protocollo Bluetooth può impiegare più tempo per scoprire peer nelle vicinanze.
\section{Risultati}
\subsubsection{L'accuratezza della cella corrente}
Il primo grafico (figura 4.2) misura l'accuratezza delle informazioni sulla cella corrente nel tempo. Ad intervalli di tempo costante e per ogni veicolo, viene calcolata la percentuale di informazioni disponibile per la cella corrente,
rispetto al numero di eventi totali che sono stati compiuti in quel quadrante.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/graphics/local_accuracy.png}
\caption{Grafico dell'accuratezza media della cella corrente al trascorrere del tempo - 3000 veicoli}
\end{figure}
L'andamento delle curve nel grafico 4.2 mostra come la tecnologia \textit{V2V}, dopo una prima fase di apprendimento di circa 400 simsec, riesca a mantenere un livello di accuratezza sull'80-85\%, raggiungendo il 90\% dopo la mezzora di simulazione.
Si ricorda che i 3000 veicoli non vengono creati tutti nell'istante 0, ma ciascuno viene inserito nello scenario in un istante che va da 0 a 1800 simsec.
Questo determina che nella fase iniziale, detta anche transiente, il numero di veicoli sia basso e per questo l'informazione non riesce a raggiungere i nodi già presenti nella città.
Man mano che altri veicoli vengono inseriti, l'accuratezza sale grazie all'aumentare delle sincronizzazioni possibili, rendendo il processo di spreading più efficace.
La tecnologia \textit{WiFi Direct} cresce meno rapidamente del \textit{V2V} a causa del minor range di comunicazione e della latenza di connessione. Si ottiene comunque un buon livello di accuratezza 
già dopo 20 minuti, mantenendosi sul 70-75\% e raggiungendo anche l'80\% a fine simulazione.
La tencologia \textit{Bluetooth} non riesce a raggiungere livelli di accuratezza soddisfacenti. La latenza di connessione e soprattutto il basso range di comunicazione incidono negativamente sulla disseminazione.
\subsubsection{L'accuratezza dello scenario generale}
Il secondo grafico (figura 4.3) misura l'accuratezza delle informazioni rispetto a tutta la città e non solo rispetto alla cella corrente in cui si trova il veicolo.
L'andamento delle curve nel grafico 4.3 può essere comparabile con quello nel grafico 4.2 con un abbassamento generale dell'accuratezza di circa un 10\%.
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{img/graphics/global_accuracy.png}
\caption{Grafico dell'accuratezza media della porzione di città al trascorrere del tempo - 3000 veicoli}
\end{figure}
Col il passare dei secondi e con l'inserimento di nuovi veicoli, la tecnologia \textit{WiFi Direct} riesce a fornire all'utente un buon livello di accuratezza generale (65-70\% dopo i primi 20 minuti, fino ad un 75\% a fine simulazione)
nonostante il range di comunicazione sia ridotto rispetto ad una tecnologia \textit{V2V}.
\subsubsection{L'accuratezza in base alla distanza}
Il grafico in figura 4.4 mostra l'accuratezza delle informazioni in base alla distanza. Ricordando che i device si sincronizzano sulle informazioni della cella corrente e su quelle strettamente adiacenti, è normale pensare
che l'accuratezza decresca con la distanza. L'ipotesi viene dimostrata dall'andamento delle curve nel grafico 4.4, dove per ogni tecnologia l'accuratezza migliore la si ottiene per la cella corrente e per quelle 
presenti nel raggio di 250-500m.
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{img/graphics/distance.png}
\caption{Grafico dell'accuratezza media in base alla distanza - 3000 veicoli}
\end{figure}
\subsubsection{L'accuratezza in base al numero di veicoli}
Il grafico in figura 4.5 mostra l'accuratezza media dopo 1800 simsec, per  ogni tecnologia, in scenari con 3000, 1500 e 500 veicoli.
Come citato in sezione 1.2, il tasso di partecipazione in sistemi Crowdsensing è un fattore determinante per un efficace processo di spreading dell'informazione.
La tecnologia \textit{V2V} riesce a mantenere livelli di accuratezza soddisfacenti anche con 1500 e 500 veicoli. Questo è determinato dall'alto range di comunicazione che il protocollo \textit{802.11p} riesce a 
garantire nella creazione di \textit{VANETs}.
L'accuratezza della tecnologia \textit{WiFi Direct}, invece, decresce notevolmente con la diminuzione dei veicoli nella porzione di città considerata.
Si passa da 70-72\% con 3000 veicoli, a 35\% con 1500 veicoli fino ad un 5\% con 500 veicoli.
Questo determina che il sistema tramite l'applicazione Android può funzionare in modo soddisfacente se il numero di utenti rimane elevato.
La tecnologia \textit{Bluetooth} non può essere considerata efficace in alcuna situazione.
\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{img/graphics/n_car.png}
\caption{Grafico dell'accuratezza media in base al numero di veicoli}
\end{figure}
\subsubsection{Falsi Positivi e Falsi Negativi}
La tabella 4.2 mostra un' analisi sull'accuratezza dei sensori Andorid. Si ricorda che viene settata la precisione dei sensori a 90\%[2].
\begin{table}[h]                        %ambiente tabella
                                        %(serve per avere la legenda)
\begin{center}                          %centra nella pagina la tabella
\begin{tabular}{ |p{2cm}||p{3cm}||p{4cm}||p{4cm}|  }
 \hline
 \textbf{vehicles}&\textbf{events avg}&\textbf{false positive avg}&\textbf{false negative avg}\\
 \hline
 3000&3695&361&369\\
 1500&1713&163&170\\
 500&514&49&48\\
 \hline
\end{tabular}
\caption{Risultati di Falsi Positivi e Falsi Negativi}\label{tab:uno}
\end{center}
\end{table}
L'analisi riguarda il calcolo dei falsi positivi e dei falsi negativi in proporzione al numero di eventi prodotti nei 1800 simsec, nella porzione di Bologna considerata. 
Per falso positivo si intende l'errore di activity recognition per cui si rileva un evento di parcheggio quando questo, in verità, non è stato compiuto.
Il falso negativo invece non rileva un evento parcheggio realmente accaduto.
I risultati ci mostrano come circa un 10\% dell'informazione, che circola all'interno della Smart City, sia realtiva a falsi positivi.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%per fare le conclusioni
\chapter*{Conclusioni}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Conclusioni
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Conclusioni}
Questa tesi descrive un sistema di Smart Parking, cercando di favorire l'attività di parcheggio dell'utente. Il sistema fornisce una mappa della città suddivisa in quadranti e per ognuno di questi viene
indicata la probabilità di trovare parcheggio. L'utente, durante la fase di parcheggio, può individuare le zone che forniscono un'alta probabilità di trovare uno slot libero.
Questo favorisce l'utente stesso, ma aiuta anche a smaltire la congestione del traffico nella metropoli.
Tramite un componente di activity recognition (basato su sensori) ogni Smartphone riesce a determinare quando l'utente parcheggia o rilascia la propria autovettura.
Il sistema si basa sul concetto di Crowdsensing, dove ogni individuo condivide i propri eventi di parcheggio e rilascio con la comunità. In base a queste informazioni è possibile dare
una stima delle zone più dense di parcheggi liberi della città. La propagazione delle informazioni non si basa su una struttura centralizzata, ma l'approccio è completamente distribuito tra i dispositivi utente.
I più comuni Smartphone in commercio danno la possibilità di comunicare tra loro secondo il paradigma \textit{D2D} (Device-To-Device).
Il meccanismo di disseminazione che è stato implementato in questo lavoro è stato reso totalmente automatico e trasparente all'utente. Una volta attivato permette di restare aggiornati sulla situazione parcheggi, 
sincronizzando spontanemante i propri dati con gli altri utenti nelle vicinanze.
I risultati ottenuti in fase di valutazione, mostrano come l'efficacia del processo di spreading cresca all'aumentare del tasso di partecipazione. Più utenti utilizzano l'applicazione, condividendo le proprie informazioni,
più resteranno aggiornati sulla situazione parcheggi in città. Con una buona partecipazione si possono ottenere risultati di poco inferiori a tecnologie molto più costose ed articolate (come ad esempio sistemi \textit{V2V}).
Questo meccanismo di disseminazione locale, oltre al problema del parcheggio, può essere facilmente adottato in altri ambiti (come ad esempio il marketing di prossimità).
In conclusione, è possibile pensare all'utilizzo del sistema in una città metropolitana in cui numerosi utenti contribuiscono al bene comune, sfruttando i servizi dell'applicazione.
Possibili sviluppi futuri potrebbero riguardare: un metodo per garantire l'esclusione di parcheggi privati (l'applicazione si basa su parcheggi on-street pubblici); un meccanismo di 
risparmio energetico e ponderare le attività di disseminazione in base allo stato della batteria; ottimizzare lo scambio dati inviando solo le entry necessarie evitando numerosi controlli; 
individuare automaticamente la cella con maggior quantità di slot liberi, in base alla destinazione dell'utente.

\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} ''I Sistemi di Trasporto Intelligenti (ITS)``, Ministero delle Infrastrutture e dei Trasporti, 2010, http://www.mit.gov.it.
\bibitem{K2} Rosario Salpietro, Luca Bedogni, Marco Di Felice, Luciano Bononi, ''Park Here! A Smart Parking System based on Smartphones' Embedded Sensors and Short Range Communication Technologies``, University of Bologna, 2015.
\bibitem{K3} Simone Masini, ''Sviluppo di una Piattaforma di Crowdsensing per l'Analisi di Dati``, Università di Bologna, 2014.
\bibitem{K4} Vladimir Coric, Marco Gruteser, ''Crowdsensing Maps of On-street Parking Spaces``, IEEE, 2013.
\bibitem{K5} Elena Polycarpou, Lambros Lambrinos, Eftychios Protopapadakis, ''Smart parking solutions for urban areas``, IEEE, 2013.
\bibitem{K6} Xiao Chen, Elizeu Santos-Neto, Matei Ripeanu, ''Crowdsourcing for on-street smart parking``, ACM, 2012.
\bibitem{K7} Rinne, Mikko, Törmä, Seppo, ''Mobile crowdsensing of parking space using geofencing and activity recognition``, Aalto University, 2014.
\bibitem{K8} Alessandro Grazioli, Marco Picone, Francesco Zanichelli, Michele Amoretti, ''Collaborative Mobile Application and Advanced Services for Smart Parking``, IEEE, 2014.
\bibitem{K9} Károly Farkas, Imre Lendák, ''Simulation Environment for Investigating Crowd-sensing Based Urban Parking``, IEEE, 2015.
\bibitem{K10} S.V. Srikanth, Pramod P.J., Dileep K.P., Tapas S., Mahesh U. Patil, Sarat Chandra Babu N., ''Design and Implementation of a Prototype Smart PARKing (SPARK) System Using Wireless Sensor Networks``, IEEE, 2009.
\bibitem{K11} Vanessa W.S. Tang, Yuan Zheng, Jiannong Cao, ''An Intelligent Car Park Management Systembased on Wireless Sensor Networks``, IEEE, 2006.
\bibitem{K12} Qing Li, Hongkun Li, Paul Russell Jr., Zhuo Chen, and Chonggang Wang, ''CA-P2P: Context-Aware Proximity-Based Peer-to-Peer Wireless Communications``, IEEE, 2014.
\bibitem{K13} Emad Abd-Elrahman, Adel Mounir Said, Thouraya Toukabri, Hossam Afifi, Michel Marot, ''A Hybrid Model to Extend Vehicular Intercommunication V2V through D2D Architecture``, IEEE, 2015.
\bibitem{K14} Jihoon Yang, Jorge Portilla and Teresa Riesgo, ''Smart Parking Service based on Wireless Sensor Networks``, IEEE, 2012.
\bibitem{K15} Muhammad Alam, Bruno Fernandes, João Almeida, Joaquim Ferreira, José Fonseca, ''Integration of Smart Parking in Distributed ITS Architecture``, IEEE, 2016.
\bibitem{K16} George Dimitrakopoulos, Panagiotis Demestichas , ''Systems Based on Cognitive Networking Principles and Management Functionality``, IEEE, 2010.
\bibitem{K17} Rongxing Lu, Xiaodong Lin, Haojin Zhu, Xuemin Shen, ''SPARK: A New VANET-based Smart Parking Scheme for Large Parking Lots``, IEEE, 2009.
\bibitem{K18} IEEE Smart Cities, http://smartcities.ieee.org/about.html.
\bibitem{K19} Feng Xia, LaurenceT.Yang, LizheWang, Alexey Vinel, ''Internet of Things``, IEEE, 2012.
\bibitem{K20} Documentazione WiFi Direct, http://www.wi-fi.org/discover-wi-fi/wi-fi-direct.
\bibitem{K21} Documentazione ufficiale Android, https://developer.android.com/index.html.
\bibitem{K22} Standard Bonjour beacon, http://files.dns-sd.org/draft-cheshire-dnsext-dns-sd.txt.
\bibitem{K23} Documentazione Android sul D2D, https://developer.android.com/training/connect-devices-wirelessly/wifi-direct.html.
\bibitem{K24} Documentazione dello standard SQLite, https://www.sqlite.org/.
\bibitem{K25} Progetto fornito da Google su WiFi Direct e Bonjour beacon, https://android.googlesource.com/.
\bibitem{K26} Documentazione del simulatore OMNeT, https://omnetpp.org/.
\bibitem{K27} Documentazione di Veins, http://veins.car2x.org/.
\bibitem{K28} Vaishali D. Khairnar, Ketan Kotecha, ''Performance of Vehicle-to-Vehicle Communication using IEEE 802.11p in Vehicular Ad-hoc Network Environment``, IEEE, 2013.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\end{document}
