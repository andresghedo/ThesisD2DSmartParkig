%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
\usepackage[labelfont=bf]{caption}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come è à
                                        %   si può usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   però con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{}                          %serve per la sillabazione
\theoremstyle{plain}                    %stile corsivo
\newtheorem{teo}{Teorema}[section]      %definizione ambiente teorema
\newtheorem{prop}[teo]{Proposizione}    %definizione ambiente proposizione
\newtheorem{cor}[teo]{Corollario}       %definizione ambiente corollario
\newtheorem{lem}[teo]{Lemma}            %definizione ambiente lemma
\theoremstyle{definition}               %stile roman
\newtheorem{defin}{Definizione}[chapter]%definizione ambiente definizione
\newtheorem{ese}{Esempio}[chapter]      %definizione ambiente esempio
\theoremstyle{remark}                   %stile per osservazioni
\newtheorem{oss}{Osservazione}          %definizione ambiente osservazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
\newcommand{\df}{\displaystyle\frac}    %crea un comando che visualizza le
                                        %   frazioni in modo più esteso
\newcommand{\seq}[1]{\left<#1\right>}   %crea un comando per il "generato"
                                        %   di un insieme, per richiamarlo
                                        %   si può scrivere ad esempio:
                                        %           $\seq{q_1,q_2}$
\begin{document}
\begin{titlepage}                       %crea un ambiente libero da vincoli
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Questa \`e la \textsc{Dedica}:\\
ognuno pu\`o scrivere quello che vuole, \\
anche nulla \ldots                      %\ldots lascia tre puntini
\newpage                                %va in una pagina nuova
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\end{titlepage}
\pagenumbering{roman}                   %serve per mettere i numeri romani
\chapter*{Introduzione}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Introduzione}
Oggigiorno, il numero di veicoli presenti nelle metropoli ha raggiunto quantità tali da portare problemi di congestione del traffico.
Si stima che una buona parte della congestione sia causata da automobilisti alla ricerca costante di un parcheggio libero.
Questa problematica causa una serie di negative conseguenze, danneggiando progressivamente gli utenti e l'ambiente.
La ricerca prolungata di uno slot libero comporta all'utente perdita di tempo e di denaro, contribuendo ad un peggioramento, anche se leggero, della qualità di vita nelle grandi città.
Inoltre, sono evidenti le conseguenze negative sull'impatto ambientale, dove la qualità dell'aria viene messa costantemente a rischio dall'enorme quantità 
di carburante che viene consumato, producendo emissioni di agenti inquinanti nell'atmosfera.
Enti governativi stanno iniziando a prendere in considerazione queste problematiche, cercando di trovare le giuste soluzioni per migliorare la situazione.
In questo senso, numerose proposte sono già presenti in letteratura, basandosi sui concetti innovativi di Smart Parking, IoT(Internet of Things) e Smart City.
Infrastrutture informatiche, comunicazione tra dispositivi eterogenei e sensoristica sono tutti elementi che possono favorire un miglior utilizzo dei parcheggi, 
fornendo agli utenti importanti indicazioni sullo stati degli slot, in una determinata zona.
Queste diventano fondamentali soprattutto se si considerano parcheggi su strada (on-street parking), i quali sono limitati e non circoscritti in precisi punti 
(al contrario di parcheggi-garage e sistemi a circuito chiuso, in cui tramite semplici apparecchiatura è possibile contare il numero di veicoli in entrata ed in uscita).
Molte soluzioni proposte prevedono l'utilizzo di sensori su strada o telecamere per comprendere l'occupazione o meno di un determinato parcheggio.
Mentre per la disseminazione delle informazioni raccolte, si propongono sistemi decentralizzati basati sull'IoT e WSN(Wireless Sensor Network), oppure classici sistemi centralizzati.
Tutti questi componenti prevedono un investimento iniziale enorme per apparecchiature ed installazione, senza contare i futuri e necessari costi di manutenzione.
Questo è ovviamente un grosso limite per i governi che spesso non sono intenzionati ad utilizzare ingenti fondi per questi scopi.
\\Il sistema che viene proposto non necessita di alcuna infrastruttura particolare e si pone l'obiettivo di fornire all'utente una stima sulle zone più dense di parcheggi liberi della città.
Questo è reso possibile tramite il concetto di crowdsensing, dove gli utenti condividono le proprie rilevazioni con altri utenti e grazie a questi continui contributi, il singolo riesce a fare 
assunzioni sulla situazione parcheggi in città.
Ogni Smartphone, avendo la possibilità di rilevare il tipo di mobilità dell'utente tramite i propri sensori, riesce a dedurre in probabilità un evento di parcheggio, piuttosto che di rilascio. 
Questi dati vengono disseminati localmente nell'ambiente ad altri device in maniera totalmente decentralizzata, permettendo agli utenti di restare aggiornati sulla situazione 
parcheggio nelle zone limitrofe.
Il servizio, una volta avviato, non avrà bisogno di alcuna interazione utente, in quanto il processo di rilevazione e di comunicazione sono stati automatizzati.
\\Questo documento viene organizzato in quattro capitoli, secondo la seguente struttura. Nel primo capitolo viene analizzato lo stato dell'arte per quanto riguarda l'argomento in questione. 
Il secondo capitolo illustra i passi di progettazione necessari alla realizzazione del sistema. Il terzo capitolo riguarda l'implementazione dell'applicazione Android, entrando nei dettagli più 
tecnici. Il quarto ed ultimo capitolo mostra la valutazione del sistema, dove i risultati sono stati ottenuti simulando il funzionamento del sistema in una città metropolitana.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoffigures                          %crea l'elenco delle figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoftables                           %crea l'elenco delle tabelle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
\clearpage{\pagestyle{empty}\cleardoublepage}
\part{Stato dell'arte}
\chapter{Stato dell'arte} 
Il seguente capitolo illustra il contesto in cui si colloca il progetto di tesi ed una serie di lavori correlati sull'argomento dello Smart Parking.
\section{Sistemi di Trasporto Intelligenti}
Il Ministero delle Infrastrutture e dei Trasporti definisce gli Intelligent Transport System(ITS, in italiano Sistemi di Trasporto Intelligenti) come 
\textit{``...range di strumenti per la gestione delle reti di trasporto, così come i servizi per i viaggiatori. Gli strumenti ITS sono basati su tre aspetti centrali: 
acquisizione, elaborazione e diffusione delle informazioni e da un minimo comune denominatore quale è l'integrazione.
I processi di acquisizione dei dati, l'elaborazione e l'integrazione degli stessi e la catena delle informazioni da fornire agli utenti del sistema di trasporto sono il cuore dei sistemi ITS''}[1].
Lo sviluppo esponenziale dell'informatica e delle reti di comunicazione ha portato alla nascita di numerose applicazione, ad alto contenuto tecnologico, per la gestione ed il controllo nell'ambito trasporti.
La gestione del traffico veicolare (acquisizione dei dati di traffico, controllo semaforico, controllo degli accessi, gestione dei parcheggi), del trasporto collettivo e della logistica (indicazioni di percorso e 
instradamento parcheggi, sistemi di distribuzione delle merci, sistemi misti merci/passeggeri, ecc...) sono esempi tangibili di come i sistemi ITS stiano diventando uno strumento prezioso per il controllo della mobilità.
Le città metropolitane sono sovraffollate di veicoli, portando a costanti situazioni di inefficienza dei trasporti, congestione del traffico ed un aumento dei tempi di percorrenza per giungere a destinazione. 
Questa situazione è in costante aumento in tutto il mondo, data l'urbanizzazione e la crescente densità di popolazione nelle grandi città.
Il 54\% della popolazione mondiale risiede in città metropolitane e si stima che possa diventare il 66\% entro il 2050[2].
\begin{figure}[!h]
\centering
\includegraphics[scale=0.7]{img/its.jpg}
\caption[Esempio di ITS]{Esempio di ITS}
\end{figure}
I sistemi ITS si pongono l'obiettivo di migliorare la qualità dei trasporti in termini di riduzione delle congestioni, rischi di incidente e situazioni di emergenza.
Per fare ciò vengono sfruttati meccanismi intelligenti, in grado di fare determinate assunzioni sulla base delle informazione scambiate tra veicoli che si trovano in una determinata zona.
Gli utenti, sfruttando le deduzioni offerte da questi sistemi, potrebbero variare il loro comportamento, permettendo così di smaltire le congestioni e favorire la viabilità generale.
\section{Crowdsensing}
Per Crowdsensing si definisce quell'attività di condivisione e raccolta dati, utilizzando i vari sensori presenti all'interno dei dispositivi. Lo scopo di ogni device deve essere quello 
di condividere con molti utenti le proprie informazioni.
In questa maniera, si potrà giungere ad una conoscenza condivisa tra gli utenti ed ottenere, in maniera intelligente, i risultati prefissati.
Il Crowdsensing si suddivide principalmente in 2 categorie[3]:
\begin{itemize}
\item \textit{Partecipatory Crowdsensing} : l'utente viene coinvolto direttamente nella fase di propagazione dei dati. 
\item \textit{Opportunistic Crowdsensing} : la propagazione avviene in maniera automatica e trasparente all'utente.
\end{itemize}
La seconda categoria, dove l'utente deve solo accettare la condivisione dei propri dati, è quella maggiormente utilizzata nelle applicazioni mobili, in quanto è quella che garantisce una buona quantità di raccolta dati.
Il Crowdsensing può essere uno strumento molto potente per ottenere risultati che possono essere ricavati soltanto dall'aggregazione di dati collettivi.
Numerosi contributi, in letteratura, si basano proprio su questo concetto. Ad esempio, il progetto in [4] utilizza il concetto di Crowdsensing per la costruzione intelligente di mappe indicanti il 
numero di parcheggi disponibili per una determinata strada.
In questo caso, prendendo un numero elevato di utenti in una determinata zona e condividendo i dati di dove essi parcheggiano abitualmente, è possibile  tracciare gli slot disponibili in una 
determinata strada.
Il sistema presentato in [8], vuole fornire agli utenti la situazione di occupazione del parcheggio universitario, tramite i dati raccolti dagli utenti.
Ogni studente quando lascia il parcheggio, contribuisce alla conoscenza globale, con la propria visione del parcheggio (pieno, semi-pieno, vuoto).
I lavori proposti sul tema dello Smart Parking in [6][9], mostrano quanto sia fondamentale il tasso di partecipazione utente.
Più utenti condividono le proprie informazioni, più l'accuratezza dei risultati sarà precisa. In particolare viene mostrato che un alto tasso di partecipazione corrisponde ad una diminuzione notevole del tempo di ricerca 
di un parcheggio.
Ogni utente condivide i propri dati sapendo di contribuire al risultato generale, avendo l'interesse nel migliorarne l'accuratezza.
Le applicazioni Crowdsensing rappresentano una possibilità di migliorare la quotidianità dell'utente.
\section{Smart City}
La \textit{IEEE} definisce la Smart City come ambiente sostenibile in grado di ridurre i consumi e fornire una qualità di vita migliore ai cittadini[18].
Il mondo tecnologico, i governi e la società dovrebbero favorire in maniera positiva il processo di urbanizzazione, riuscendo a proporre le seguenti caratteristiche nella città intelligente:
\begin{itemize}
\item smart mobility
\item smart economy
\item smart environment
\item smart people
\item smart living
\item smart governance
\end{itemize}
La Smart City si pone l'obiettivo di semplificare ogni operazione della città, grazie agli ultimi sviluppi tecnologici.
Soprattutto la recente espansione del paradigma IoT (Internet of Things, in italiano Internet delle Cose) ha permesso l'apertura verso nuove applicazioni, in grado di portare miglioramenti nella vita metropolitana.
In [19], si definisce l'Internet delle Cose come \textit{``l'interconnessione in rete di oggetti di uso quotidiano, formando una rete distribuita di dispositivi, comunicanti con l'uomo o con altri dispositivi''}.
\\Ogni dispositivo potrà aumentare il proprio livello di intelligenza grazie all'interconnessione ed alle informazioni derivanti da altri device.
\\Il progetto di tesi può essere visto come un primo passo verso il tema dello Smart City, dove numerosi dispositivi vengono coinvolti per migliorare un aspetto quotidiano dei cittadini.
\section{Smart Parking}
Il problema del parcheggio può essere visto come una grossa sfida all'interno delle Città intelligenti, definite nella sezione 1.3.
Con il termine Smart Parking si intendono tutte quelle soluzioni che intendono favorire l'utente nell'attività di parcheggio.
Secondo recenti studi, la maggior parte della congestione veicolare nelle grandi città è causata dai parcheggi.
Gli utenti passano molto tempo nel cercare uno slot libero, soprattutto se si considerano parcheggi su strada (on-street parking).
\\Le conseguenze negative di tutto ciò si possono riassumere in:
\begin{itemize}
\item perdita di tempo
\item perdita di denaro
\item inquinamento ambientale
\item peggioramento della qualità di vita
\end{itemize}
Lo studio in [4], quantifica gli effetti negativi evidenziando come in una porzione di Los Angeles, nel periodo di un anno, le macchine abbiano compiuto una distanza pari a 
37 giri intorno al mondo, soltanto per le attività di ricerca parcheggio.
Questo ha portato al consumo di 47000 galloni di gasolio, tramutati in 730 tonnellate di CO\ped{2} (diossido di carbonio) emesso nell'aria.
Un'altra analisi molto interessante viene fatta in [5], dove si dimostra come gli utenti, non trovando parcheggio in un tempo ragionevole, si comportino in maniera negativa.
Molte persone sarebbero disposte a parcheggiare illegalmente o addirittura rinunciare all'attività da compiersi.
Lo stato dell'arte presenta numerosi lavori sul tema dello Smart Parking, proponendo idee sempre più innovative per limitare gli effetti negativi appena descritti.
In [4] si cerca di fornire all'utente una mappa dettagliata della quantità di parcheggi per strada. Questa può essere un'informazione utile per l'utente, il quale riesce quantomeno a farsi un'idea sulle strade 
più dense di parcheggi on-street.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.4]{img/sensor-sp.png}
\caption{Sistema di Smart parking con sensori in-ground}
\end{figure}
I progetti mostrati in [5][10][11][14][15] si affidano a reti \textit{WSN} (Wireless Sensor Network), dove ogni sensore viene posizionato in prossimità del parcheggio (come mostrato in figura 1.2) ed instrada le proprie 
informazioni verso una struttura centralizzata.
L'efficienza di questi sistemi è molto alta, ma il costo per l'installazione e la manutenzione (come riportato anche nell'Introduzione) sono un limite per la loro diffusione.
Questo ha favorito lo sviluppo di sistemi Crowdsensing e Crowdsourcing permettono di ottenere risultati soddisfacenti, partendo dal contributo degli utenti stessi.
I progetti in [2][4][7][8][9] forniscono all'utente, tramite l'ausilio di mappe, indicazioni riguardo la situazione parcheggi nelle vicinanze. 
Gli utenti che compiono un'attività di parcheggio, condividono i propri dati (ottenuti tramite sensori dello Smartphone o altro) con la comunità, evitando congestione del traffico stradale.
Questi lavori possono essere correlati all'attività di tesi presentata in questo documento, dove si cercherà di fornire agli utenti preziose informazioni sui parcheggi vicini, 
senza l'aiuto di architetture \textit{WSN} ed agenti centralizzati.
\subsection{Propagazione dell'informazione}
Una parte fondamentale all'interno dei sistemi Smart City e Smart Parking riguarda la propagazione dei dati tra i diversi utenti. Innanzitutto è bene distinguere la comunicazione secondo due paradigmi:
\begin{itemize}
\item \textit{centralizzata} : classica struttura Client-Server, dove una struttura centralizzata raccoglie tutti i dati derivanti da diverse fonti della Smart City e fornisce i risultati ai diversi client.
\item \textit{distribuita} : ogni dispositivo comunica con altri dispositivi cercando di propagare efficacemente l'informazione. L'assenza di una struttura centralizzata porta ogni nodo ad avere risultati 
parziali nel tempo, di conseguenza è necessario pensare ad efficaci metodi di propagazione in modo che tutti gli utenti restino allineati sulle informazioni prodotte dalla città.
\end{itemize}
Il secondo paradigma è quello che verrà utilizzato in questo lavoro di tesi, dove gli attori della rete saranno solamente dispositivi end-point. 
Risparmiando l'utilizzo di agenti centralizzati, si evitano importanti costi di installazione e gestione.
Il tema dello Smart Parking porta a considerare la Smart City come una rete veicolare distribuita ed in queste condizioni è normale pensare ad una comunicazione V2V (Vehicle-To-Vehicle).
Il V2V riguarda comunicazioni tra veicoli in movimento portanto alla creazione di resti spontanee, denominate VANETs (Vehicular ad hoc networks).
Questi tipi di sistemi sono stati realizzati per propagare informazioni in maniera totalmente distribuita tra i vecoli, segnalando eventuali pericoli, incidenti, percorsi trafficati.
Ad oggi questo tipo di comunicazione non è disponibile per molte delle auto in commercio, trattandosi comunque di progetti costosi ed altamente innovativi.
Un altro modo di propagazione distribuita può avvenire invece tramite l'utilizzo di Smartphone, utilizzando il paradigma D2D (Device-To-Device).
Il D2D permette comunicazioni wireless distribuita tra device che sono nelle vicinanze. Questo approccio è quello che viene preso in considerazione nel lavoro di tesi, sfruttando i dispositivi utente per la 
propagazione di informazioni, relativa alla situazione parcheggi, all'interno della Smart City.
\part{Progettazione ed Implementazione}
\chapter{Progettazione}                %crea il capitolo
Il seguente capitolo ha lo scopo di illustrare in dettaglio il goal del progetto, le problematiche che vi stanno dietro ed il processo di progettazione su cui è stato necessario soffermarsi, per la successiva realizzazione ed implementazione.
\\La mission, descrivendola in pochi concetti, è sostanzialmente quella di determinare quando un utente parcheggia o rilascia uno slot e disseminare queste informazioni in maniera totalmente distribuita, senza alcun appoggio di una struttura centralizzata.
Questo concetto diventa innovativo dal momento in cui non si passa dalla rete cellulare o da qualche gateway verso Internet per la comunicazione tra dispositivi, 
ma la comunicazione avverrà esclusivamente peer-to-peer, utilizzando tecnologie presenti nei più comuni device in commercio.
\\Quello che si vuole fornire all'utente sono delle probabilità di trovare parcheggio in una determinata zona della città, piuttosto che in altre.
\\Dettagli tecnologici ed implementativi saranno comunque discussi nel prossimo capitolo.
\\Di seguito verranno illustrati soprattutto le principali strutture che compongono il sistema, descrivendone funzionalità, utilità ed integrazione con le restanti componenti.
\section{Scopo e problematiche}                 %crea la sezione
Come già accennato e discusso in precedenza lo scopo principale è quello di propagare informazioni, tra dispositivi mobili, in maniera completamente distribuita, senza l'appoggio di agenti centralizzati.
Il device utente, tramite la componente di Activity Recognition presente nel software, rileva un evento di parcheggio o rilascio, dopo di chè tiene traccia dell'evento salvandolo in memoria locale.
\\Le informazioni campionate, sopradescritte, saranno l'oggetto della comunicazione tra i device che potranno fare assunzioni su eventuali zone dense di parcheggi liberi.
Più gli utenti restano allineati e sincronizzati su questi dati, più restano aggiornati e consapevoli della situazione parcheggi nei dintorni.
Per scelta progettuale, la città viene divisa in celle (identificate con id univoci), permettendo così alla logica di disseminare informazioni relative alla cella in questione e a quelle adiacenti.
Un altro aspetto non meno importante di quelli già illustrati, è il fatto che il servizio deve funzionare in modo continuativo nel tempo e soprattutto in maniera totalmente autonoma.
Questo significa che l'utente, senza nessuna interazione con il device (mantenendolo per esempio in tasca), sincronizza comunque i propri dati con quelli di utenti circostanti, nei paraggi.
La funzionalità appena descritta, per renderla robusta, ha richiesto una fase implementativa consistente, la quale verrà illustrata tecnicamente nel Cap.3.
\section{Scenario generale}                 %crea la sezione
Lo scenario che si va a considerare per l'utilizzo di un'applicazione di questo genere è una città metropolitana.
Questa può essere diversamente interpretata e suddivisa logicamente in una griglia composta da celle (quadranti), dove ognuna di queste viene identificata univocamente da una coppia di  coordinate X e Y.
Queste coordinate sono considerati come indici matriciali che individuano una cella all'interno della matrice griglia della città. 
Si presuppone che il numero di parcheggi disponibili in una data cella sia un dato noto a priori, il quale comprende tutti gli slot disponibili nelle strade che sono logicamente raggruppate, all'interno del 
quadrante considerato.
Si ricorda che si fa riferimento a parcheggi pubblici su strada e non a strutture private o a circuito chiuso.
\\Il device dell'utente, tramite l'implementazione presente nell'app, performando un evento di parcheggio o rilascio, riesce a recuperare la cella in cui risiede logicamente e registrerà nel proprio database locale 
che l'evento si è verificato in quello specifico quadrante.
Le assunzioni sulla probabile quantità, in percentuale, di parcheggi liberi vengono calcolate sulla granularità della cella.
\\In fase di progettazione, si è giunti alla conclusione che non è sufficiente scambiarsi il numero di parcheggi liberi/occupati derivanti da dati statistici, 
in quanto ogni utente potrebbe avere una parziale, ma diversa, visione dello scenario.
Da ciò deriva la necessità di sincronizzarsi su tutti gli eventi che sono successi recentemente in una determinata zona (cella) e quelle adiacenti.
Quando due peer cercheranno di sincronizzarsi verranno scambiate le informazioni relative alla cella corrente e quelle adiacenti.
In questo modo, si cerca di fornire all'utente, previsioni più precise sulle celle che sono nei pressi della posizione corrente del device.
Questo evita overhead nella comunicazione e sincronizzazione di entries che non sono utili all'utente.
Rimanendo nel discorso di overhead, è normale pensare che questo modello possa ``esplodere``, in quanto la mole di dati potrebbe diventare enorme con il passare del tempo, così come le opportunità di sincronizzazione.
Per evitare che questo succeda, viene controllata la dimensione del database locale, ed eventualmente eliminate le entries meno aggiornate.
Inoltre i peers possono effettuare sincronizzazioni soltanto dopo una certa threshold, espressa in secondi.
Questi concetti sono stati parametrizzati in fase di implementazione, quindi possono essere giustamente calibrati in base all'ambiente in cui si intende utilizzare l'app.

\section{Architettura generale}               %crea la sezione
L'architettura generale, analizzandola da un punto di vista esterno, prevede come unici attori i device utenti. Questi muovendosi all'interno dell'ambiente città restano in attesa di possibili sincronizzazioni.
Ogni dispositivo, che presenta il servizio di comunicazione e sincronizzazione attivo, può interpretare fondamentalmente due ruoli concettuali:
\begin{itemize}
 \item \textbf{ROLE ACCESS POINT}:
 \\Il device funge da Access Point, offrendo la possibilità a device presenti in prossimità di agganciarsi all'HotSpot esposto. Una volta che un Client si connette stabilmente ad esso avrà  l'opportunità di aprire 
 un canale di comunicazione e sincronizzare i propri dati con quelli del Access Point, denominato anche come Server.
 Inoltre l'Access Point notifica la propria presenza e informazioni utili attraverso la propagazione di un beacon di servizio.
 \item \textbf{ROLE CLIENT}:
 \\Se un device si accorge della presenza di un HotSpot nelle vicinanze, grazie al beacon sopracitato, può tentare di connettersi come Client all'Access Point. Qualora riesca ad agganciarsi in modo stabile 
 verranno avviati i canali di comunicazione, su cui effettuare una sincronizzazione tra i device Client e Server.
\end{itemize}
A questo punto la topologia della rete generale può essere vista come hub di hub, ovvero tante piccole star, dove grazie al movimento inerziale dei device si riuscirà ad ottenere una propagazione dell'informazione, 
interconnettendo appunto diverse star tra di loro, ad istanti di tempo differenti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/arch_general.png}
\caption[Rappresentazione dell'Architettura generale]{Rappresentazione dell'Architettura generale e della divisione in celle di una porzione di Bologna}
\end{figure}
\\Come si può comprendere dalla figura 2.1, i device muovendosi continuamente all'interno dello scenario (identificato in questo caso con la griglia città), formeranno continuamente nuove star, con attori sempre diversi. Questo 
fattore è determinante per il processo di propagazione delle informazioni, in quanto dati presenti in una star, verranno sincronizzati, in istanti successivi, con star diverse.
L'analisi dello spreading delle informazioni, la sua efficacia ed accuratezza sono illustrate nel Cap.4, nel quale si cerca di capire se questo meccanismo è attuabile nella realtà.

\section{Architettura software}               %crea la sezione
Prima della fase di implementazione, è stato necessaria una fase di progettazione dell'architettura software. L'applicazione, per essere considerata utilizzabile dagli utenti ed efficace nel meccanismo di 
spreading, necessita di numerosi componenti e soprattutto dell'interazione tra essi.
\\Nella figura 2.2 sono stati messi i componenti principali che concettualmente compongono l'architettura e come questi collaborano.
Di seguito vengono spiegati i compiti che ogni struttura deve compiere per la corretta esecuzione dell'applicativo sotware:
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/arch_soft.png}
\caption{Rappresentazione dell'Architettura software}
\end{figure}
\begin{itemize}
\item \textbf{Componente di Activity Recognition:}
\\Il componente di activity recognition si preoccupa di rilevare gli eventi di parcheggio e rilascio, che un determinato utente compie, col trascorrere del tempo. Questo è possibile tramite l'utilizzo dei sensori, 
i quali campionano periodicamente lo stato di accelerometro e giroscopio, mappandoli tramite un algoritmo decisionale in un'attività ben definita.
Questo processo, in realtà, si compone di due fase come training e recognition.
La prima è necessaria alla seconda e riguarda il campionamento dei dati sensore in una attività definita dall'utente di CAR o NO\_CAR. La seconda, invece, grazie ai campioni rilevati nella prima riuscirà a 
fare assunzione sul tipo di attività che l'utente sta svolgendo.
Quando il componente capisce che si è passato da uno stato CAR ad uno stato NO\_CAR, significa che l'utente ha parcheggiato l'autovettura, mentre, dualmente, se si passa da uno stato NO\_CAR a CAR, significa che 
l'utente ha rilasciato uno slot.
Quando una di queste due situazioni accade, si registra l'evento nel database locale.
\item \textbf{Componente Database locale:}
\\Il Database locale si preoccupa di raccogliere le informazioni sul device utente, le quali poi verranno processate per calcolare la probabilità di parcheggio in una determinata zona.
Le informazioni che vengono memorizzate sono illustrate più precisamente nella sezione 2.5.
\item \textbf{Componente Controller:}
\\Il Controller si preoccupa di scrivere, aggiornare e dare accesso alle informazioni presenti nel database locale. Inoltre, è stato pensato come semplice meccanismo di Object-Relational Mapping(ORM), 
per integrare al meglio le logiche ad oggetti con i dati presenti nel DBMS. 
\\Sostanzialmente, può essere interpretato come un oggetto Controller, del pattern MVC (Model-View-Controller), gestendo ed implementando le classi del Modello.
\item \textbf{Componente Frontend:}
\\Il frontend sono sostanzialmente le views che verranno mostrate all'utente, sul proprio device Android. Si è optato per un frontend semplice, per rendere utilizzabile l'app a qualsiasi tipo di utente, 
pur fornendo ad esso tutte le informazioni necessarie sullo stato dei parcheggi nelle vicinanze.
Nella sezione Screenshot è possibile prendere visione del layout grafico pensato per l'applicazione.
\item \textbf{ Componente Dissemination Service:}
\\Il componente di disseminazione delle informazioni è il cuore del progetto e l'elemento più articolato all'interno dell'architettura.
Questo è composto da diversi sottocomponenti, la maggior parte dei quali verranno illustrati con precisione nel capitolo di implementazione.
Il disseminatore è un servizio che gira in background e la logica è scandita da una FSM (Finite State Machine), dove in base allo stato in cui ci si trova verranno compiute azioni, piuttosto che altre.
Quando viene rilevata una nuova connessione ad un peer, il componente si preoccupa anche di gestire il corretto funzionamento della comunicazione, 
gestendo i canali di input e output verso gli altri device, nel range di comunicazione.
\end{itemize}
\subsection{Organizzazione dell'informazione}                 %crea la sezione
L'organizzazione dei city data è ovviamente una fase determinante del progetto.
Si è optato per la realizzazione di un database di tipo relazionale, composto principalmente da due tabelle, indipendenti l'una dall'altra.
\\La prima tabella, denominata, park\_events colleziona tutti gli eventi che gli utente compiono o ricevono in seguito a sincronizzazioni con altri utenti.
\\La seconda tabella synchronizations colleziona invece tutte le sincronizzazioni che hanno coinvolto il device in questione.
\\Come verrà illustrato nel Cap.4 relativo all'implementazione, gli strumenti utilizzati si baseranno completamente sullo standard SQL, i quali permetteranno una semplice gestione di 
query di filtraggio, creazione, modifica, cancellazione.
\\Entrando più in dettaglio nella composizione delle tabelle e degli attributi salvati, si mostra di seguito uno schema riassuntivo di ciò che viene messo a database:
\\\\ Tabella \textbf{\textit{park\_events}}:
\begin{itemize}
\item \underline{\textit{cell\_id}} : identificativo univoco della cella che la identifica all'interno della grid city. Informazione di tipo geografica.
\item \underline{\textit{event}} : evento che può essere limitatamente PARKED o RELEASED. Indica se l'entry fa riferimento ad una sosta o alla liberazione di un parcheggio.
\item \underline{\textit{timestamp}} : datetime che indica il momento in cui è stato performato l'evento in questione.
\item \underline{\textit{mac}} : identificativo univoco del device che ha performato l'evento di parcheggio o rilascio.
\end{itemize}
La PRIMARY KEY è composta da \underline{\textit{\textless timestamp, mac\textgreater}}. L'idea che vi sta dietro è quella che un utente può performare, in un dato istante, al più un unico 
evento di rilascio o parcheggio.
\\\\ Tabella \textbf{\textit{synchronizations}}:
\begin{itemize}
\item \underline{\textit{timestamp}} : datetime in cui è avvenuta la sincronizzazione.
\item \underline{\textit{mac}} : id univoco dell'altro device con cui è stata possibile la sincronizzazione.
\item \underline{\textit{ap\_role}} : booleano che indica se ero Access Point o meno al momento della sincronizzazione.
\end{itemize}

Questa tabella oltre a fini statistici,  è importante perché permette di evitare che due device si sincronizzino in continuazione.
Grazie all'attributo timestamp, si riesce a risalire all'ultima sincronizzazione che ha coinvolto il device e di conseguenza, è possibile settare una time threshold, sotto la quale 
non è possibile iniziare una nuova sincronizzazione.
Le logiche implementate a backend non permettono lo scambio di dati in istanti troppo vicini tra loro.
Questo meccanismo può esser visto come un minimo di salvaguardia da cicli continui o sovrapposizione di sincronizzazioni.

\subsection{Network State Machine}                 %crea la sezione
Come già accennato nell'architettura software, il processo di disseminazione delle informazioni è scandito da una macchina a stati finiti.
Si è deciso di approfondire questo componente per far comprendere meglio come vengono gestite le sincronizzazioni tra i device utente coinvolti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/nsm.png}
\caption{Network State Machine}
\end{figure}
\\Alla partenza del servizio, il device, non ha conoscenza dell'ambiente circostante, di conseguenza si rende disponibile come ruolo di Access Point ed entra nello stato STATE\_ACCESS\_POINT\_NO\_PEERS.
Quando si riesce a scoprire la presenza di altri peer, nei paraggi, si entra nello stato STATE\_ACCESS\_POINT\_PEERS.
A questo punto, il device, si mette all'ascolto di eventuali beacon di servizio, i quali potrebbero notificare la presenza di un preesistente AccessPoint.
\\Se questo non accade, il device rimane disponibile come ruolo di Access Point, notificando la propria presenza in beaconing e fornendo opportunità di sincronizzazioni ad eventuali client in arrivo (stato OPEN\_SERVER\_SOCKET).
\\Diversamente, se il device comprende la presenza di un Access Point già consolidato in zona, smette di svolgere il ruolo di HotSpot e comincia a comportarsi come Client, entrando, di conseguenza, 
nello stato STATE\_CONNECTION.
Ora il device cerca di connettersi all'HotSpot, esposto grazie alla tecnologia WiFiDirect.
Se il processo porta ad una connessione stabile e ad un assegnazione di un indirizzo IP, verrà automaticamente aperto un canale di comunicazioni bidirezionali tra il Client e Server, iniziando così la fase 
di sincronizzazione (stato IN\_SYNC).
\\Come si può notare dallo schema in figura 2.3, dallo stato STATE\_CONNECTION vi è anche la possibilità di ripartire dall'inizio, nel caso in cui, il device non riesca a connettersi all'HotSpot in un tempo ragionevole, 
entro una certa threshold.
Questo è stato fatto per evitare situazioni di stallo e cercare di ripartire da un punto più stabile.
Supponendo che la sincronizzazione sia andata a buon fine, si passa allo stato STATE\_SYNCED\_CONNECTED, il quale significa che la sincronizzazione è terminata ma si è ancora agganciati all'HotSpot del Server.
A questo punto, gli attori coinvolti, potrebbero allontanarsi a tal punto da rompere il legame creato e quindi il servizio ripartirebbe dallo stato iniziale di START.
Altrimenti, se gli utenti restano nelle vicinanze l'uno dell'altro, in modo tale da mantenere attiva la connessione, si dà l'opportunità al Client (dopo una certa threshold) di richiedere nuovamente una sincronizzazione.

\section{Probabilità di occupazione di una cella}                 %crea la sezione
Questa parte si preoccupa, man mano che le informazioni giungono nel database locale, di calcolare le probabilità di trovare parcheggio in una determinata cella della città, piuttosto che in altre.
\\Si ricorda che il dato che si fornisce all'utente è una probabilità e non un valore certo, così da dare indicazioni agli utenti, sulle zone, che statisticamente saranno meno congestionate, in termini di slot occupati.
\\Un'altra precisazione riguarda  il fatto che più utenti utilizzeranno l'applicazione, come supporto al parcheggio, e più dati verranno disseminati tra i device, aumentando progressivamente l'affidabilità 
delle probabilità fornite agli utenti.
\\Supponendo che il numero di slot totali in una generica cella i, identificato con la sigla N\ped{i}\ap{t}, sia noto a priori, lo si può interpretare anche come la somma tra numero di slot liberi, N\ped{i}\ap{f}, e 
numero di slot occupati N\ped{i}\ap{o}.
Questi ultimi due, possono essere ricavati a partire dagli eventi di parcheggio e rilascio, i quali sono presenti nel database locale citato in precedenza.
\\In particolare, il numero dei parcheggi occupati N\ped{i}\ap{o} può essere ricavato dalla differenza tra il numero di eventi parcheggio E\ped{i}\ap{p} ed il numero di eventi rilascio E\ped{i}\ap{r}.

$$N\ped{i}\ap{o} = E\ped{i}\ap{p} - E\ped{i}\ap{r} $$
\\A questo punto, conoscendo già il numero totale degli slot, è facile calcolare il tasso di occupazione di una determinata cella:
$$p\ped{i}\ap{o} = \df{N\ped{i}\ap{o}}{N\ped{i}\ap{t}}$$
\\Infine calcoliamo la probabilità di trovare parcheggio, servendosi del tasso di occupazione appena calcolato:
$$p\ped{i}\ap{f} = 1 - p\ped{i}\ap{o}$$
Quest'ultima sarà l'informazione, messa in percentuale, a cui l'utente avrà accesso una volta aperta l'applicazione, dove verrà visualizzata la mappa della città suddivisa in griglia ed ogni quadrante sarà colorato in base alla 
probabilità di trovare parcheggio.
\\Nella sezione screenshot, figura 3.2, è possibile vedere quanto descritto.


\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Implementazione}                %crea il capitolo
Come ribadito nel Cap. 2 l'obiettivo del progetto è quello di disseminare informazioni di smart parking in modalità Device-to-Device, senza l'ausilio di alcuna infrastruttura di rete intermediaria. 
In base alle informazioni ricevute, si riuscirà dunque a fare assunzioni sulle quantità di parcheggi disponibile in determinate zone della città.
\\L'implementazione riguarda la realizzazione del processo sopradescritto nel Sistema Operativo Android, con l'ausilio della tecnologia WiFiDirect.
Quest'ultima, presente a partire dalle librerie API 14 e device con Android 4.0 o superiori, permette la comunicazione one-to-one tra dispositivi utente.
\\Il capitolo seguente mostra i passi necessari alla realizzazione, dettagliando i componenti software realizzati partendo dalla base di progettazione, illustrata nel Cap.2.
\section{Componente di disseminazione}                 %crea la sezione
Il paragrafo illustra tutte gli attori principali che compongono il servizio di disseminazione delle informazioni. Si è cercato di spiegare, in ogni sottoparagrafo, le funzionalità
del componente e l'interazione con gli altri. Questa è la parte che, in fase di implementazione, ha richiesto maggior sforzo ed essendo il cuore del progetto, verrà maggiormente descritta, addentrandosi anche
nell'analisi del sorgente.
\subsection{Strategia di connessione tramite WiFiDirect}
La tecnologia WiFi Direct rende possibile la creazione di cosiddetti P2P Groups, i quali possono essere comparati ad infrastrutture WiFi. 
Il device che detiene le funzionalità di Access Point viene definito P2P Group Owner, il quale può comunque mantenere attive connessioni cellulari (come ad esempio il 4G).
Per realizzare lo scopo del progetto il WiFi Direct non è stato utilizzato in maniera tradizionale, bensì in modalità legacy.
\\Questo perchè, almeno nel primo incontro tra due device, la nascita della connessione necessità dell'interazione utente (come mostrato in figura XX).
\\Il nostro processo di comunicazione peer-to-peer non prevede però alcuna interazione dell'utente, in quanto i dispositivi devono scoprirsi e comunicare in maniera del tutto autonoma e trasparente.
\\Utilizzando la modalità legacy, un dispositivo crea un P2P Group fungendo da Access Point, mentre gli altri lo percepiscono e si connettono ad esso come un normale HotSpot 802.11.
Questo dà la possibilità di connettere più client per Access Point, formando logicamente le topologie a stella, citate nel paragrafo di Architettura generale, nel Cap. 2.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/popup.png}
\caption{Interazione utente per il consenso alla connessione}
\end{figure}
\subsection{Il servizio background}
Il processo di comunicazione tra peers avviene in maniera completamente trasparente all'utente, per questo è stato necessario implementare un servizio che svolgesse 
il meccanismo di invio e ricezione dati, anche nel caso in cui l'applicazione venisse chiusa.
Un Service è un componente Andorid, sprovvisto di interfaccia grafica, che si preoccupa di compiere procedure totalmente in background.
Questo componente, presente nel package services, viene denominato NetworkAutoService, ed estende appunto la classe Service di Andorid.
\begin{itemize}
 \item onCreate : Si preoccupa di creare il servizio e notificare l'utente di ciò con l'apparizione di un Toast.
 \item onStartCommand : Metodo che inizia l'esecuzione vera e propria del servizio in background. Qui, sostanzialmente, espone in beaconing la 
 possibilità di fungere da AccessPoint e si mette alla ricerca di preesistenti HotSpot nei paraggi. Queste funzionalità verranno descritte meglio in seguito.
Inoltre richiama il metodo privato startCheckNetworkTimer, illustrato tra poche righe.
Richiamando tale funzione il servizio è attivo e pronto per il processo di sincronizzazione e disseminazione.
Si ricorda che la partenza di questo è sancita dall'utente tramite interfaccia grafica, alla pressione di un pulsante.
 \item onDestroy : Metodo che ferma il servizio e libera le strutture dati necessarie al processo di networking. L'utente richiama implicitamente questo metodo alla pressione del bottone di Stop del servizio.
 \item startCheckNetworkTimer : Metodo privato che inizializza un oggetto Timer e lo schedula ogni 30s. Questi 30s possono essere interpretati logicamente come un time slot. 
 L'azione schedulata, prevede l'invio di un Broadcast Intent, in modo tale che il BroadCast Receiver lo possa catturare e controllare lo stato della macchina a stati finiti, definita in fase di progettazione.
\end{itemize}
\subsection{Il NetworkController}
Il NetworkController si preoccupa di fornire gli strumenti necessari alla gestione degli attori coinvolti nel processo di networking e disseminazione locale delle informazioni.
Questo oggetto è stato implementato seguendo le linee guida del Pattern Singleton.
Questo pattern permette, fondamentalmente, di creare una ed una sola istanza di una particolare classe, rendendola disponibile in ottica globale. 
Il concetto è quello di avere oggetti Java che permettano di avere controllo, in ogni punto del progetto, sulle componenti fondamentali dell'architettura implementata.
Infatti, la mansione principale di questa classe è proprio quella di esporre le istanze degli oggetti che permettono la realizzazione del processo di disseminazione locale.
Tramite questa è possibile accedere all'oggetto NetworkServiceSearcher, NetworkAccessPoint e NetworkConnection.
Il primo, come verrà illustrato in seguito, si preoccupa di segnalare la presenza di beacon di servizio nelle vicinanze, il secondo governa eventuali funzionalità da Access Point del device, 
mentre il terzo implementa funzionalità client per connettersi ad HotSpot nei paraggi.
Inoltre, il NetworkController, registra in una variabile lo stato corrente della Network Machine State, la quale scandisce logicamente il processo di spreading.
Infine, espone metodi per la registrazione e rilascio del BroadcastReceiver.
Di seguito vengono elencate i metodi principali che la classe espone:
\begin{itemize}
\item startAccessPoint / stopAccessPoint : Metodi che decretano l'inizio, o la fine, del device come Access Point.
\item startConnection / stopConnection : Metodi che cercano di connettersi, o scollegarsi, da un HotSpot.
\item startServiceSearcher / stopServiceSearcher : Metodi che sanciscono l'inizio, o la fine, della ricerca di beacon di servizio nelle vicinanze.
\end{itemize}
\subsection{Connessione ad un Access Point}
La classe NetworkConnection, concettualmente molto semplice, detiene la procedura necessaria per connettersi in maniera automatica ad un AccessPoint, presente nella lista ricavata dallo scan delle reti circostanti.
Questa classe viene utilizzata quando un device, tramite l'arrivo di un beacon, capisce che vi è un Access Point attivo e disponibile a soddisfare richieste di sincronizzazione.
Infatti, questo, assumerà il ruolo di Client cercando di agganciarsi all'HotSpot individuato.
\\È necessario ricordare che, per effettuare queste procedure in maniera completamente automatica e trasparente all'utente, vi è la necessità di conoscere la passphrase per connettersi. 
Questa come vedremo, sarà ricavata dai beacon di servizio, già accennati in precedenza.
\\Di seguito viene mostrato il codice discusso:
\begin{verbatim}
...

public class NetworkConnection {

  public static String TAG= "[DEBAPP]NetworkConnection";

  WifiManager wifiManager = null;
  WifiConfiguration wifiConfig = null;
  Context context = null;

  public NetworkConnection(Context Context, String SSIS, String passphrase) {
    Log.d(TAG, "New WiFiConnection @ AP SSID: " + SSIS + 
          " with psw: " + passphrase + " ..... ");
    this.context = Context;

    this.wifiManager = (WifiManager)this.context.getSystemService(
                                            this.context.WIFI_SERVICE);

    /* disable others */
    for (WifiConfiguration cnf:this.wifiManager.getConfiguredNetworks()) {
        this.wifiManager.disableNetwork(cnf.networkId);
    }

    /* set passphrase */
    this.wifiConfig = new WifiConfiguration();
    this.wifiConfig.SSID = String.format("\"%s\"", SSIS);
    this.wifiConfig.preSharedKey = String.format("\"%s\"", passphrase);

    /* try to reconnect with new config */
    int id = this.wifiManager.addNetwork(this.wifiConfig);
    this.wifiManager.enableNetwork(id, false);
    this.wifiManager.reconnect();
  }

  public void Stop(){
    Log.d(TAG, "Remove connection with AP!!");
    this.wifiManager.disconnect();
  }
}
\end{verbatim}
\subsection{Esplorazione dell'ambiente circostante}
Questa classe ha lo scopo di capire la situazione nell'ambiente esterno, scoprendo quanti e quali attori vi sono nelle vicinanze e comportarsi di conseguenza.
Ogni device, per decidere se fungere da AccessPoint o se connettersi come client ad un HotSpot già esistente, ha bisogno di comprendere ed essere avvisato della presenza o meno di altri host nell'ambiente locale.
\subsubsection{Scoperta di peers}         %crea la sottosezione
La classe WiFiP2PManager di Android, permette di gestire tramite chiamate API la connessione peer-to-peer tra device.
Molte chiamate implementate fanno riferimento ad eventi asincroni, di conseguenza è stato necessario implementare Listener in modo tale da porre determinate logiche, al succedersi di determinati eventi.
Uno di questi può essere individuato nella scoperta di peers, dove si prende nota dell'eventuale presenza di altri device Android nell'ambiente circostante.
Questo può essere ritrovato nella funzione startPeerDiscovery della classe NetworkBeaconPeerSearcher, dove viene richiamato il metodo discoverPeers del WiFiP2PManager.
A questo punto il device è pronto a notificare la presenza di eventuali peers nelle vicinanze.
Per catturare queste notifiche è stato necessario implementare un personale PeerListListener, il quale grazie al metodo onPeersAvailable (WifiP2pDeviceList peers) restituisce la lista dei peers presenti nei paraggi.
\subsubsection{Beacon di servizio}         %crea la sottosezione
Sempre nell'ambito peer-to-peer, la tecnologia Android, permette di pubblicizzare un servizio ad altri device prima di un'effettiva connessione tra i dispositivi.
La documentazione per developer di Android, specifica che questo meccanismo è stato fatto per individuare, in una fase iniziale, peer che esponessero determinati servizi, piuttosto che altri.
Questa funzionalità è stata fondamentale per la realizzazione del progetto, in quanto permette di fare assunzioni prima di effettuare tentativi di connessione tra peer.
In un primo momento si è pensato di inserire le informazioni relative agli eventi parcheggio direttamente all'interno di questi pacchetti, in quanto vi è la possibilità di inserire un tipo di dato Map\textless String, String \textgreater.
Con questo tipo di meccanismo si sarebbe potuto attuare il cosiddetto piggybacking, inserendo il vero payload direttamente dentro a questi pacchetti di servizio.
Questa strategia, oltre ad abbassare notevolmente la complessità, avrebbe permesso di scambiare dati in broadcast tra device, senza che questi instaurassero una connessione.
L'implementazione però non è resa possibile a causa del basso contenuto, in termini di dimensione, che può contenere il tipo di dato Map\textless String, String\textgreater.
Lo standard consiglia di tenere questo contenuto sotto i 200 bytes e non è raccomandato superare i 1300 bytes. Provando empiricamente, si è potuto confermare la restrinzione appena citata.
Gli ArrayList degli eventi che vogliamo sincronizzare hanno un contenuto maggiore del limite tecnologico imposto, per questo motivo si è dovuto virare sul meccanismo di AccessPoint e connessioni automatiche.
Questi pacchetti risultano comunque determinanti, in quanto incapsuleranno la stringa passphrase, necessaria ai client per connettersi in maniera automatica all'HotSpot esposto.
Tornando al progetto, è possibile scoprire questi servizi tramite il metodo startBeaconDiscovery, il quale chiama a sua volta il metodo discoverServices del WiFiP2PManager.
Il Listener, relativo alla scoperta di un servizio, riguarda la creazione di un oggetto DnsSdServiceResponseListener, il quale implementando il metodo onDnsSdServiceAvailable, fornisce in input tutte le 
infomazioni necessario sul servizio appena scoperto (ad esempio nome, tipo, device).
\subsubsection{Logiche di scoperta}         %crea la sottosezione
Nei precedenti due sottoparagrafi si è cercato di illustrare le funzionalità principali che si ritrovano nella classe NetworkBeaconPeerSearcher, illustrando le funzioni API chiave utilizzate.
Ora si cercherà di spiegare la logica che è stato necessario implementare e come la scoperta di peers e servizi si interfacciano tra loro.
Quando un device scopre la presenza di almeno un peer attorno a lui, si mette immediatamente all'ascolto di eventuali servizi esposti da altri utenti.
Nel momento in cui si scoprisse un servizio idoneo che indichi la presenza di un D2DSmartParking AccessPoint, in attesa di possibili sincronizzazioni, viene mandato 
un broadcast Intent tale da notificare al BroacastReceiver di iniziare il processo di connessione all'HotSpot trovato.
La classe che implementa tutte queste funzionalità è abbastanza ampia, per questo, di seguito, si mostra il solo codice relativo ai Listeners citati nel paragrafo.
\begin{verbatim}
...
peerListListener = new WifiP2pManager.PeerListListener() {
  public void onPeersAvailable(WifiP2pDeviceList peers) {
    int nPeers = 0;
    for (WifiP2pDevice peer : peers.getDeviceList()) {
        nPeers++;
        Log.d(TAG, "PEER FOUND: " + peer.deviceName);
    }
    /* if there is someone, looking for D2DSP service */
    if(nPeers > 0){
        Log.d(TAG, "Search for a D2DSP service...");
        NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_ACCESS_POINT_PEERS;
        startBeaconDiscovery();
     } else { /* else search peers */
        Log.d(TAG, "Search for peers...");
        NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_ACCESS_POINT_NO_PEERS;
        startPeerDiscovery();
    }
  }
};
...
serviceListener = new WifiP2pManager.DnsSdServiceResponseListener() {
  public void onDnsSdServiceAvailable(String serv, String type, 
                                                 WifiP2pDevice dev) {
    if (serviceType.startsWith(NetworkTestFragment.SERVICE_TYPE)) {
        if(broadcaster != null) {
            Log.d(TAG, "find a D2DSP beacon!");
            Intent intent = new Intent(Constants.INTENT_D2D_AP_FOUND);
            intent.putExtra(Constants.INTENT_D2D_AP_ACCESSDATA, serv);
            context.sendBroadcast(intent);
        }
    } else {
        Log.d(TAG, "This service is not for me!");
    }
    /* continue search peers */
    startPeerDiscovery();
  }
};
...
\end{verbatim}
\subsection{Funzionalità Access Point-like}
Le funzionalità necessarie ad un device per interpretare il ruolo di Access Point, sono definite nella classe NetworkAccessPoint.
Queste, sostanzialmente, riguardano la creazione spontanea e autonoma di un WiFi Direct Group, con la conseguente autoelezione a Group Owner.
La classe implementa delle interfacce astratte Android, le quali permettono di catturare segnali relativi alla gestione del WiFiDirect Group.
In particolare, l'interfaccia WifiP2pManager.GroupInfoListener permette di essere notificati quando il Gruppo è stato creato.
Questo è permesso dal metodo onGroupInfoAvailable (WifiP2pGroup group), dove in input vengono date tutte le informazioni necessarie sul gruppo appena formato.
A questo punto all'interno del metodo si richiama una procedura startBeaconAP
 per creare ed esporre il servizio di notifica, in modo tale da che gli utenti esterni riescano, tramite questo beacon, a connettersi automaticamente all'HotSpot.
Oltre a questa operazione viene fatto partire il meccanismo per ricevere connessioni in input tramite Socket, operazione che verrà approfondita in seguito.
Come citato in precedenza, il beacon incorpora l'informazione di passphrase in modo tale che la connessione possa avvenire in maniera automatica tramite la classe NetworkConnection.
Il codice sottostante mostra la creazione del gruppo tramite il metodo createGroup e l'esposizione del servizio in merito alla notifica della corretta creazione della rete:
\begin{verbatim}
...
/* Creation of Group */
public void start() {

  p2p = (WifiP2pManager) NetworkController.getInstance().managerP2P;

  if (p2p == null) {
    Log.d(TAG, "Wi-Fi Direct NOT SUPPORTED, BYE!");
  } else {
    channel = NetworkController.getInstance().channel;
    /* WiFi Direct Group creation */
    p2p.createGroup(channel,new WifiP2pManager.ActionListener() {
      public void onSuccess() {
        Log.d(TAG, "WiFiDirect Group created!!");
      }
      public void onFailure(int reason) {
        Log.d(TAG, "Error in creation, error code " + reason);
      }
    });
  }
}
...
@Override
public void onGroupInfoAvailable(WifiP2pGroup group) {
  try {
    Log.d(TAG, "WiFi Direct Net is created, expose beacon service...");
    ...
    startBeaconAP("D2DSP:" + group.getNetworkName() + ":" + 
                         group.getPassphrase() + ":" + netAddress);
    ...
    /* Start Socket Server for synchronizations with clients */
    if(NetworkController.getInstance().server == null) {
      NetworkController.getInstance().server = new Server();
    }
  } catch(Exception e) {
    Log.d(TAG, "onGroupInfoAvailable, error: " + e.toString());
  }
}
...
private void startBeaconAP(String instance) {
  /* beacon fot notify client of Access Point presence */
  Map<String, String> record = new HashMap<String, String>();
  record.put("D2DSP", "apactive");

  WifiP2pDnsSdServiceInfo service =
                     WifiP2pDnsSdServiceInfo.newInstance(
                        instance, Constants.SERVICE_TYPE, record);

  p2p.addLocalService(channel, service, 
                     new WifiP2pManager.ActionListener() {
    public void onSuccess() {
      Log.d(TAG, "Beacon is in air!");
    }
    public void onFailure(int reason) {
      Log.d(TAG, "Adding local service failed, error code " + reason);
    }
  });
}
...
\end{verbatim}
\subsection{Canali di comunicazione}
Una volta che l'Access Point crea la rete ed altri peer riescono a connettersi, identificandosi con un indirizzo IP, si può passare all'apertura dei canali di comunicazione ed alla sincronizzazione degli 
eventi di parcheggio/rilascio.
I canali di comunicazione si basano su Socket serializzate, permettendo di inviare e ricevere, con un semplice casting, direttamente degli ArrayList\textless ParkEvent \textgreater.
L'AccessPoint, appena notificato dell'avvenuta creazione del gruppo, richiama la creazione di un oggetto di tipo Server, il quale istanzia una ServerSocket, mettendosi in ascolto di eventuali richieste Socket dai 
client, con il metodo accept().
I clients invece, quando notificati dal BroadcastReceiver dell'avvenuta connessione all'HotSpot, creano un oggetto Socket con l'indirizzo IP del Server e la porta idonea.
Ora che il canale di comunicazione bidirezionale è stato messo in piedi, il Server invierà il proprio ArrayList nell' ObjectOutputStream della Socket, grazie al metodo writeObject. 
Il Client coinvolto, vedendosi arrivare le informazioni nel canale ObjectInputStream, le memorizza in una variabile ed invia le proprie, ripetendo il procedimento sopradescritto a parti inverse.
Una volta chiuso il canale, viene fatto il merge delle entries ricevuto con quelle già presenti in memoria.
Si precisa che tutti i meccanismi descritti vengono gestiti tramite Thread, in modo tale che il processo di sincronizzazione non risulti bloccante.
Anche le classi Client e Server sono corpose dal punto di vista del codice, di conseguenza si illustra il codice dei passi salienti.

\begin{verbatim}
### CLIENT SIDE ###
public class Client implements Runnable {
  ...
  public void run() {
    try {
      ...
      Socket socket = new Socket(serverAddr, Constants.PORT);
      ArrayList<ParkEvent> parkEventsFromOther;

      while (true) {
        ...
        try {
          ObjectInputStream objectInStream = 
              new ObjectInputStream(socket.getInputStream());
          parkEventsFromOther = 
              (ArrayList<ParkEvent>) objectInStream.readObject();
          ...
          break;
        } catch (Exception e) {
        }
      }
      ...
      while(run) {
        try {
         ObjectOutputStream objectOutStream = 
             new ObjectOutputStream(socket.getOutputStream());
         objectOutStream.writeObject(Controller.getInstance().parkEvents);
         break;
        } catch (IOException e) {
         run = false;
        }
      }
     socket.close();
     /* merge new entries*/
     Controller.getInstance().mergeEntries(parkEventsFromOther);
     /* register sync */
     Controller.getInstance().insertSynchronizationOnSQLiteDB(
                        false, macWithSync);
     /* change stati in NSM*/
     NetworkController.getInstance().networkStateMachine = 
                           Constants.STATE_SYNCED_CONNECTED;
    } catch (Exception e) {
    }
  }
}
### SERVER SIDE ###
...
/* Thread that attend for client socket requests */
private class SocketServerThread extends Thread {

  @Override
  public void run() {
    try {
      /* create ServerSocket using specified port */
      serverSocket = new ServerSocket(Constants.PORT);
      while (true) {
        Socket socket = serverSocket.accept();
        /* thread for socket sync with client - logic of 
         socketServerReplyThread are same of Client Side */
        SocketServerReplyThread socketServerReplyThread = 
             new SocketServerReplyThread(socket);
        socketServerReplyThread.run();
      }
    } catch (IOException e) {
    }
  }
}
...
\end{verbatim}
\subsection{L'ascoltatore BroadcastReceiverManagement}
Un componente fondamentale, a livello implementativo, è senza dubbio il BroadcastReceiverManagement. Questo estende la classe Android BroacastReceiver ed è in grado di 
ricevere avvisi sia dall'app stessa, che da componenti esterni di sistema.
Per avvisi si intendono Intent, i quali vengono catturati dal metodo onReceive della classe.
Questi oggetti possono tranquillamente lavorare in background e ricevere aggiornamenti anche se l'applicazione è chiusa.
Si è definito fondamentale in quanto qui vengono prese tutte le decisioni riguardanti il networking, in base ai segnali ricevuti automaticamente in input.
La classe può essere interpretata anche come un decisore, che in base al succedersi di determinati eventi, compie precise azioni.
Di seguito vengono illustrati i comportamenti fondamentali, in base a determinati Intent in input. Le istruzioni condizionali citate sono tutte all'interno del metodo onReceive.
\begin{itemize}
\item Tentativi di connessione : 
\\All'arrivo di un custom Intent INTENT\_D2D\_AP\_FOUND, il sistema capisce che è stato scoperto un AccessPoint attivo nelle vicinanze e cerca di connettersi ad esso, 
utilizzando la passphrase ricavata dal becon di servizio.
\begin{verbatim}
...
if (Constants.INTENT_D2D_AP_FOUND.equals(action)) {
  /* get beacon data */
  String serv = 
         intent.getStringExtra(Constants.INTENT_D2D_AP_ACCESSDATA);
  String[] separated = serv.split(":");
  
  /* stop my Access Point functionalities */
  if(NetworkController.getInstance().networkConnection == null) {
    NetworkController.getInstance().stopNetworkAccessPoint();
    NetworkController.getInstance().stopNetworkBeaconPeerSearcher();
    /* Now I'm a simple Client */
    String networkSSID = separated[1];
    String networkPass = separated[2];
    String ipAddress   = separated[3];

    Log.d(TAG, "start new connection @ " + networkSSID);
    /* start connection mechanism */
    NetworkController.getInstance().networkConnection = 
        new NetworkConnection(ctx, networkSSID,networkPass);
    /* networkStateMachine update */
    NetworkController.getInstance().networkStateMachine = 
        Constants.STATE_CONNECTION;
  }
}
...
\end{verbatim}

\item Gestione dello stato di connessione :
\\L'intent WifiManager.NETWORK\_STATE\_CHANGED\_ACTION decreta un cambiamento di stato della connessione WiFi del device. Se è avvenuta una 
disconnessionem il device torna disponibile ad interpretare il ruolo di Access Point, mentre se è decretata la connessione ad un HotSpot inizierà il procedimento di sincronizzazione, lato Client.
\begin{verbatim}
...
if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(action)) {
  NetworkInfo info = 
      intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
  if(info != null) {
    if (info.isConnected()) {
      ...
     }else {
       /* connection with AP is lost */
       if(this.connetionState.equals(Constants.CONN_STATE_CONNECTED)){
         Log.d(TAG, "WiFi DIS-Connecting...");
         this.connetionState = Constants.CONN_STATE_DISCONNECTED;
       }
     }
    if(this.connetionState.equals(Constants.CONN_STATE_DISCONNECTED)){
      /* start access point funztionalities */
      ...
    }
  }
  WifiInfo wiffo = 
      intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO);
  if(wiffo != null){/* I'm now connected! */
    /* open client socket channel*/
    this.runThreadSync(context);
  }
}
...
\end{verbatim}

\item Sincronizzazioni successive :
\\Come ribadito in fase di progettazione, se un Client mantiene la propria connessione attiva con l'Access Point per un certo periodo, anche dopo aver effettuato una prima sincronizzazione con esso, 
ha la possibilità di effettuare un successivo scambio dati, dopo una certa threshold.
Il componente quindi, periodicamente, controlla lo stato della Network State Machine e se il device continua a trovarsi nello stato STATE\_SYNCED\_CONNECTED anche dopo la soglia stabilita, può effettuare 
un'ulteriore comunicazione con l'HotSport Server.
\begin{verbatim}
...
if(Constants.INTENT_D2D_CHECK_MACHINE_STATE.equals(action)) {
...
  /* check for threshold */
  boolean isPossibleSync = Controller.getInstance().isPossibleSync();
  String state = NetworkController.getInstance().networkStateMachine;
  if((state.equals(Constants.STATE_SYNCED_CONNECTED))&&(isPossibleSync)) {
      ...
      /* re-synchronized client side */
      this.runThreadSync(context);
  }
...
}
...
\end{verbatim}
\end{itemize}
\newpage
\section{Screenshot}                 %crea la sezione
Di seguito sono mostrati gli screenshot dell'applicazione D2DSP:
\begin{figure}[!h]
\centering
\includegraphics[scale=0.2]{img/screenshot/map.jpg}
\caption[Screenshot della mappa di Bologna con probabilità di parcheggio]{Mappa del centro di Bologna divisa in celle, ognuna colorata con la relativa probabilità di trovare parcheggio}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_ap_no_peers.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/state_ap_peers.jpg}
\caption[Screenshot della schermata Network State Machine(1)]{Servizio di disseminazione attivo negli stati STATE\_ACCESS\_POINT\_NO\_PEERS e STATE\_ACCESS\_POINT\_PEERS}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_conn.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/state_in_sync.jpg}
\caption[Screenshot della schermata Network State Machine(2)]{Servizio di disseminazione attivo negli stati STATE\_CONNECTION e STATE\_IN\_SYNC}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/state_synced_connected.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/activity_recogn.jpg}
\caption[Screenshot della schermata di Activity Recognition]{Servizio di disseminazione attivo negli stati STATE\_SYNCED\_CONNECTED e schermata del componente di Activity Recognition}
\end{figure}
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.15]{img/screenshot/last_sync.jpg}%   "%" necessario
\qquad\qquad
\includegraphics[scale=0.15]{img/screenshot/park_event_list.jpg}
\caption[Screenshot delle liste di sincronizzazioni ed eventi parcheggio]{Schermate che mostrano all'utente le ultime sincronizzazioni effettuate e gli eventi parcheggio, con possibilità di filtro}
\end{figure}
\clearpage{\pagestyle{empty}\cleardoublepage}
\part{Valutazione}
\chapter{Valutazione}
Quest'ultima fase riguarda la valutazione del processo di disseminazione delle informazioni, grazie alla quale riusciamo a comprendere come le informazioni si propagano all'interno del mondo che si va a considerare.
\\È importante comprendere che non si andrà a valutare la precisione delle probabilità di parcheggi liberi, bensì si andrà a verificare come gli utenti restano allineati sulle informazioni prodotte e propagate dagli agenti dello scenario.
Infatti l'importante è che l'utente riesca a sincronizzarsi efficacemente con gli altri attori circostanti, in maniera tale da restare aggiornato, durante il movimento, sulla cella corrente e su quelle adiacenti.
\section{Strumenti}
Ovviamente non è possibile testare lo spreading delle informazioni in un ambiente reale, di conseguenza ci si affida ad un simulatore ad eventi discreti.
In ambito accademico lo strumento più efficace ed utilizzato per fare simulazione è senza dubbio OMNeT++.
Questo prodotto, disponibile in open source dal 2003, viene utilizzato in fase di progettazione, ricerca, testing e analisi di protocolli di rete, architetture software e hardware.
L'ambiente di sviluppo è un surrogato di Eclipse ed il linguaggio principale è il C++.
\\La logica del simulatore si basa sul concetto fondamentale di Modulo, i quali possono essere aggregati e customizzati a seconda delle proprie esigenze.
In particolare, per la valutazione del progetto e dell'architettura pensata è stato necessario sviluppare un componente SmartParking che riproponesse la logica pensata in fase di progettazione ed 
implementata conseguentemente.
Come verrà illustrato in sezione 4.2, sono stati parametrizzati gli aspetti che influenzano maggiormente lo spreading dell'informazione, in modo tale da comprendere le differenze al variare delle condizioni.
\\L'utilizzo di OMNeT viene integrato dall'apporto di SUMO e di Veins.
Il primo è un simulatore di mobilità urbana, anch'esso ottenibile in open source, che si preoccupa di emulare reti stradali, anche di grosse dimensioni.
Tutte le configurazioni necessarie per il corretto funzionamento di questo, definite in file xml, riguardano la definizione delle strade, delle costruzioni presenti nell'ambiente e dalle macchine(di cui, 
per ognuna, viene specificato il tempo di partenza ed il percorso da effettuare).
La gestione di questi file risulta complicata quando si vanno a simulare intere città, in quanto la mole di dati diventa importante.
Veins è un framework open source, scritto anch'esso in C++, che fornisce una grossa quantità di moduli preimplementati, per la simulazione di protocolli wireless in ambito veicolare.
Inoltre fornisce lo strumento TraCi che permette l'interazione tra i simulatori SUMO e OmNet, in modo che questi lavorino simultaneamente sull'esecuzione dello scenario definito dall'utente.
\\I risultati delle simulazioni possono essere visualizzati direttamente da un apposita interfaccia grafica fornita da OMNeT ma possono anche essere esportati in vari formati. Si è scelto di esportare i risultati
in formato CSV, per poi analizzarli tramite degli script PHP.
\section{Modellazione}
La città presa in considerazione per l'analisi simulata del processo di disseminazione locale, è naturalmente Bologna.
In realtà, viene presa in considerazione soltanto una porzione di questa, più precisamente la zona nord-est del centro storico fino ad arrivare in zona Bologna fiere, fuori dall'anello del centro.
Quantificandola, l'area appare come un rettangolo di 2.5 km per 1.5 km, per un totale di 3.75 km\ap{2}.
Comprendendo le strutture universitarie e la stazione dei treni, si tratta di una zona abbastanza movimentata e del tutto idonea al testing dell'architettura implementata.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/sumo-bolo.png}
\caption[Interfaccia grafica SUMO di Bologna]{Interfaccia grafica di SUMO che mostra la porzione di Bologna per la simulazione}
\end{figure}
\\La struttura implementata permette di parametrizzare determinate metriche in fase di configurazione, le quali vengono citate in elenco:
\begin{itemize}
\item \underline{\textit{range}} : quando i due dispositivi risiedono l'uno nel range trasmissivo dell'altro la comunicazione avrà esito positivo. Misura espressa in metri.
\item \underline{\textit{min\_latency}} : latenza minima che un utente aspetta per effettuare una sincronizzazione. Misura espressa in secondi.
\item \underline{\textit{max\_latency}} : latenza massima che un utente può verificare prima che avvenga una sincronizzazione o un fallimento. Misura espressa in secondi.
\item \underline{\textit{sensor\_accuracy}} : accuratezza dei device android nel performare l'evento di activity recognition rilascio o parcheggio. Misura espressa in percentuale da 0 a 1, compresi.
\item \underline{\textit{synchronization\_time}} : tempo minimo per cui un utente deve aspettare prima di poter ri-sincronizzarsi. Misura espressa in secondi.
\item \underline{\textit{cell\_size}} : lunghezza del lato di una cella, espresso in metri.
\end{itemize}
La logica progettata per la simulazione è una versione semplificata di quella implementata nell'applicazione Android ma rappresenta comunque fedelmente il modello, in modo che i risultati 
ottenuti possano essere ritenuti affidabili.
I dispositivi si possono sincronizzare continuamente nel tempo ma, per problemi di overhead già citati, tra due scambi di dati deve passare una certa threshold, rappresentata nel modello dal parametro 
\textit{synchronization\_time}.
\\I parametri di \textit{min\_latency} e \textit{max\_latency} rappresentano il tempo che gli AccessPoint e i Client ci mettono per identificare il loro ruolo, scoprire peer, rilevare beacon e connettersi ad un WiFiDirect Group.
\section{Obiettivi di simulazione}
In fase di simulazione, si vuole dimostrare che il movimento inerziale degli utenti e la strategia di disseminazione locale, permettono di restare sincronizzati sugli eventi che effettivamente accadono.
In particolare si cercherà di analizzare l'accuratezza dei dati presenti nei database locali ai device utente, rispetto a ciò che è accaduto realmente.
\\Per definire meglio il concetto dell'accuratezza, si prenda di riferimento una cella \textit{i} dove, nel lasso di tempo \textit{t}, sono stati performati 100 eventi parcheggio o rilascio.
A questo punto, in un determinato istante \textit{t\ped{i}}, se il device ha nella propria conoscenza locale 10 eventi dei 100 totali, avrà un'accuratezza del 10\%, se ne ha 50 avrà accuratezza del 50\% e così 
fino al limite superiore del 100\%, il quale può essere raggiunto solo da una struttura di tipo centralizzata.
L'accuratezza, appena descritta, verrà calcolata e registrata nel corso del tempo per comprendere il relativo andamento, col trascorrere dei secondi.
Inoltre verrà stabilita l'accuratezza in relazione alla distanza, per capire il grado di allineamento non solo sulle celle strettamente adiacenti, ma anche su quelle progressivamente più lontane.
Infine verrà presa in considerazione l'accuratezza in base al numero di veicoli presenti nella porzione di Bologna considerata.
\\Tutte queste misurazioni verranno comparate simulando diverse tecnologie, in modo tale da capire dove si colloca l'implementazione tramite WiFiDirect.
\section{Configurazioni e run}
Si vogliono comparare le metriche sopradescritte, simulando l'architettura con l'utilizzo di tre tecnologie differenti quali VANET V2V, WiFi Direct e Bluetooth.
Il tempo per ogni run di simulazione è stato settato a 1800 simsec (mezzora simulata) e per ogni tecnologia si considerano scenari con 3000, 1500 e 500 veicoli.
\\Per ottenere un'analisi statistica che abbia un senso, si effettuano 10 run indipendenti per ogni tecnologia e numero di veicoli, per un totale di 90 run indipendenti.
I risultati saranno frutto delle medie dei vari run con la stessa configurazione.
\subsubsection{VANET V2V}
Per simulare la tecnologia presente nei sistemi V2V, basato sull'\textit{802.11p}, si settano i parametri di \textit{range}, \textit{min\_latency} e \textit{max\_latency} in modo tale che il range di comunicazione sia piuttosto elevato, 
sui 500m, e che la \textit{min\_latency} e \textit{max\_latency} siano azzerate.
Questi ultimi due parametri vengono annullati in quanto la logica descritta in fase di progettazione ed implementata sull'app Android, su questi sistemi, non ha senso di esistere.
I canali di comunicazione V2V non necessitano di un meccanismo di esposizione dell'HotSpot e connessione a questo da parte dei client.
\subsubsection{WiFi DIRECT}
Questa configurazione rispecchia l'architettura progettata ed implementata sull'applicazione Android. Il range di comunicazione si aggira sui 100m, 
con latenza di apertura dei canali di comunicazione che va dai 2 ai 10 secondi.
\subsubsection{BLUETOOTH}
La terza tecnologia che si vuole considerare è il Bluetooth, il quale ha un range di comunicazione sui 20m ed una latenza di connessione che va dai 5 ai 15 secondi.
Quest'ultimi parametri possono essere visti come un approccio ottimistico, in quanto il protocollo Bluetooth può impiegare più tempo per scoprire peer nelle vicinanze.
\\\\
\begin{table}[h]                        %ambiente tabella
                                        %(serve per avere la legenda)
\begin{center}                          %centra nella pagina la tabella
\begin{tabular}{ |p{4.8cm}||p{2cm}||p{2.5cm}||p{2.5cm}|  }
 \hline
 \multicolumn{4}{|c|}{\textbf{Simulation parameters}} \\
 \hline
 \textbf{technology}&V2V&WiFiDirect&Bluetooth\\
 \textbf{range(m)}&500&100&20\\
 \textbf{min\_latency(s)}&0&2&5\\
 \textbf{max\_latency(s)}&0&10&15\\
 \textbf{sensor\_accuracy(\%)}&0.90&0.90&0.90\\
 \textbf{synchronization\_time(s)}&20&20&20\\
 \textbf{cell\_size(m)}&250&250&250\\
 \textbf{sim time(simsec)}&1800&1800&1800\\
 \hline
\end{tabular}
\caption[parametri di simulazione]{parametri di simulazione}\label{tab:uno}
\end{center}
\end{table}
\section{Risultati}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%per fare le conclusioni
\chapter*{Conclusioni}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Conclusioni
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Conclusioni} Queste sono le
conclusioni.\\
In queste conclusioni voglio fare un riferimento alla
bibliografia: questo \`e il mio riferimento \cite{K3,K4}.

\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} ''I Sistemi di Trasporto Intelligenti (ITS)``, Ministero delle Infrastrutture e dei Trasporti, 2010, http://www.mit.gov.it.
\bibitem{K2} Rosario Salpietro, Luca Bedogni, Marco Di Felice, Luciano Bononi, ''Park Here! A Smart Parking System based on Smartphones' Embedded Sensors and Short Range Communication Technologies``, University of Bologna, 2015.
\bibitem{K3} Simone Masini, ''Sviluppo di una Piattaforma di Crowdsensing per l'Analisi di Dati``, Università di Bologna, 2014.
\bibitem{K4} Vladimir Coric, Marco Gruteser, ''Crowdsensing Maps of On-street Parking Spaces``, IEEE, 2013.
\bibitem{K5} Elena Polycarpou, Lambros Lambrinos, Eftychios Protopapadakis, ''Smart parking solutions for urban areas``, IEEE, 2013.
\bibitem{K6} Xiao Chen, Elizeu Santos-Neto, Matei Ripeanu, ''Crowdsourcing for on-street smart parking``, ACM, 2012.
\bibitem{K7} Rinne, Mikko, Törmä, Seppo, ''Mobile crowdsensing of parking space using geofencing and activity recognition``, Aalto University, 2014.
\bibitem{K8} Alessandro Grazioli, Marco Picone, Francesco Zanichelli, Michele Amoretti, ''Collaborative Mobile Application and Advanced Services for Smart Parking``, IEEE, 2014.
\bibitem{K9} Károly Farkas, Imre Lendák, ''Simulation Environment for Investigating Crowd-sensing Based Urban Parking``, IEEE, 2015.
\bibitem{K10} S.V. Srikanth, Pramod P.J., Dileep K.P., Tapas S., Mahesh U. Patil, Sarat Chandra Babu N., ''Design and Implementation of a Prototype Smart PARKing (SPARK) System Using Wireless Sensor Networks``, IEEE, 2009.
\bibitem{K11} Vanessa W.S. Tang, Yuan Zheng, Jiannong Cao, ''An Intelligent Car Park Management Systembased on Wireless Sensor Networks``, IEEE, 2006.
\bibitem{K12} Qing Li, Hongkun Li, Paul Russell Jr., Zhuo Chen, and Chonggang Wang, ''CA-P2P: Context-Aware Proximity-Based Peer-to-Peer Wireless Communications``, IEEE, 2014.
\bibitem{K13} Emad Abd-Elrahman, Adel Mounir Said, Thouraya Toukabri, Hossam Afifi, Michel Marot, ''A Hybrid Model to Extend Vehicular Intercommunication V2V through D2D Architecture``, IEEE, 2015.
\bibitem{K14} Jihoon Yang, Jorge Portilla and Teresa Riesgo, ''Smart Parking Service based on Wireless Sensor Networks``, IEEE, 2012.
\bibitem{K15} Muhammad Alam, Bruno Fernandes, João Almeida, Joaquim Ferreira, José Fonseca, ''Integration of Smart Parking in Distributed ITS Architecture``, IEEE, 2016.
\bibitem{K16} George Dimitrakopoulos, Panagiotis Demestichas , ''Systems Based on Cognitive Networking Principles and Management Functionality``, IEEE, 2010.
\bibitem{K17} Rongxing Lu, Xiaodong Lin, Haojin Zhu, Xuemin Shen, ''SPARK: A New VANET-based Smart Parking Scheme for Large Parking Lots``, IEEE, 2009.
\bibitem{K18} IEEE Smart Cities, http://smartcities.ieee.org/about.html.
\bibitem{K19} Feng Xia, LaurenceT.Yang, LizheWang, Alexey Vinel, ''Internet of Things``, IEEE, 2012.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\end{document}
