%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%12pt: grandezza carattere
                                        %a4paper: formato a4
                                        %openright: apre i capitoli a destra
                                        %twoside: serve per fare un
                                        %   documento fronteretro
                                        %report: stile tesi (oppure book)
\documentclass[12pt,a4paper,openright,twoside]{report}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per scrivere in italiano
\usepackage[italian]{babel}
\usepackage[labelfont=bf]{caption}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per accettare i caratteri
                                        %   digitati da tastiera come è à
                                        %   si può usare anche
                                        %   \usepackage[T1]{fontenc}
                                        %   però con questa libreria
                                        %   il tempo di compilazione
                                        %   aumenta
\usepackage[latin1]{inputenc}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per impostare il documento
\usepackage{fancyhdr}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per avere l'indentazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   all'inizio dei capitoli, ...
\usepackage{indentfirst}
%
%%%%%%%%%libreria per mostrare le etichette
%\usepackage{showkeys}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per inserire grafici
\usepackage{graphicx}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%libreria per utilizzare font
                                        %   particolari ad esempio
                                        %   \textsc{}
\usepackage{newlfont}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%librerie matematiche
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amsthm}
%
\oddsidemargin=30pt \evensidemargin=20pt%impostano i margini
\hyphenation{}                          %serve per la sillabazione
\theoremstyle{plain}                    %stile corsivo
\newtheorem{teo}{Teorema}[section]      %definizione ambiente teorema
\newtheorem{prop}[teo]{Proposizione}    %definizione ambiente proposizione
\newtheorem{cor}[teo]{Corollario}       %definizione ambiente corollario
\newtheorem{lem}[teo]{Lemma}            %definizione ambiente lemma
\theoremstyle{definition}               %stile roman
\newtheorem{defin}{Definizione}[chapter]%definizione ambiente definizione
\newtheorem{ese}{Esempio}[chapter]      %definizione ambiente esempio
\theoremstyle{remark}                   %stile per osservazioni
\newtheorem{oss}{Osservazione}          %definizione ambiente osservazione
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%comandi per l'impostazione
                                        %   della pagina, vedi il manuale
                                        %   della libreria fancyhdr
                                        %   per ulteriori delucidazioni
\pagestyle{fancy}\addtolength{\headwidth}{20pt}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection \ #1}{}}
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\cfoot{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\linespread{1.3}                        %comando per impostare l'interlinea
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%definisce nuovi comandi
\newcommand{\df}{\displaystyle\frac}    %crea un comando che visualizza le
                                        %   frazioni in modo più esteso
\newcommand{\seq}[1]{\left<#1\right>}   %crea un comando per il "generato"
                                        %   di un insieme, per richiamarlo
                                        %   si può scrivere ad esempio:
                                        %           $\seq{q_1,q_2}$
\begin{document}
\begin{titlepage}                       %crea un ambiente libero da vincoli
                                        %   di margini e grandezza caratteri:
                                        %   si pu\`o modificare quello che si
                                        %   vuole, tanto fuori da questo
                                        %   ambiente tutto viene ristabilito
\thispagestyle{empty}                   %elimina il numero della pagina
\topmargin=6.5cm                        %imposta il margina superiore a 6.5cm
\raggedleft                             %incolonna la scrittura a destra
\large                                  %aumenta la grandezza del carattere
                                        %   a 14pt
\em                                     %emfatizza (corsivo) il carattere
Questa \`e la \textsc{Dedica}:\\
ognuno pu\`o scrivere quello che vuole, \\
anche nulla \ldots                      %\ldots lascia tre puntini
\newpage                                %va in una pagina nuova
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\end{titlepage}
\pagenumbering{roman}                   %serve per mettere i numeri romani
\chapter*{Introduzione}                 %crea l'introduzione (un capitolo
                                        %   non numerato)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
INTRODUZIONE}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INTRODUZIONE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Introduzione
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Introduzione}
Questa \`e l'introduzione.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\tableofcontents                        %crea l'indice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries\leftmark}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
INDICE}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoffigures                          %crea l'elenco delle figure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\listoftables                           %crea l'elenco delle tabelle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter{Primo Capitolo}                %crea il capitolo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\pagenumbering{arabic}                  %mette i numeri arabi
Il seguente capitolo ha lo scopo di illustrare in dettaglio il goal del progetto, le problematiche che vi stanno dietro ed il processo di progettazione su cui è stato necessario soffermarsi, per la successiva realizzazione ed implementazione.
La mission, descrivendola in pochi concetti, è sostanzialmente quella di disseminare le informazioni, relative al concetto di Smart Parking, in maniera totalmente distribuita e senza alcun appoggio di una struttura centralizzata.
Questo concetto diventa innovativo dal momento in cui non si passa dalla rete cellulare o da qualche gateway verso Internet per la comunicazione tra dispositivi, ma verranno utilizzate soltanto le tecnologie e apparecchiature presenti nei più comuni smartphone in commercio.
Dettagli tecnologici ed implementativi saranno comunque discussi nel prossimo capitolo.
Di seguito verranno illustrati soprattutto le principali componenti che compongono il sistema, descrivendone funzionalità, utilità ed integrazione con le restanti componenti.
\section{Scopo e problematiche}                 %crea la sezione
Come già accennato e discusso in precedenza lo scopo principale è quello di propagare informazioni, tra dispositivi mobili, in maniera completamente distribuita, senza l'appoggio di agenti centralizzati.
Il device utente, tramite la componente di Activity Recognition presente nel software, compie un evento di parcheggio o rilascio, dopo di chè tiene traccia dell'evento salvandolo in locale nella memoria.
Le informazioni campionate sopra descritte, saranno l'oggetto della comunicazione tra i device che potranno fare assunzioni su eventuali zone dense di parcheggi liberi.
Più gli utenti restano allineati e sincronizzati su questi dati, più restano aggiornati e consapevoli della situazione parcheggi nei dintorni.
Per semplicità concettuale la città viene divisa in celle(identificate con id univoci), permettendo così alla logica di disseminare informazioni relative alla cella in questione e a quelle adiacenti.
Un altro aspetto non meno importante di quelli già illustrati, è il fatto che il servizio deve funzionare in modo continuativo nel tempo e soprattutto in modo totalmente autonomo.
Questo significa che l'utente, senza nessuna interazione con il device(mantenendolo per esempio in tasca), sincronizza comunque i propri dati con quelli di utenti circostanti, nei paraggi.
La funzionalità appena descritta, per renderla robusta, ha richiesto una fase implementativa consistente, la quale verrà illustrata tecnicamente in seguito.
\section{Scenario generale}                 %crea la sezione
Lo scenario che si va a considerare per l'utilizzo di un'applicazione di questo genere è una città metropolitana.
Questa può essere diversamente interpretata e suddivisa logicamente in una griglia composta da celle(quadranti), dove ognuna di queste viene identificata univocamente da una coppia di  coordinate X e Y.
Si presuppone che il numero di parcheggi disponibili in una data cella sia un dato noto a priori, il quale comprende tutti gli slot disponibili nelle strade che sono logicamente raggruppate, all'interno del 
quadrante considerato.
Il device dell'utente, tramite l'implementazione presente nell'app, performando un evento di parcheggio o rilascio, riesce a recuperare la cella in cui risiede logicamente e registrerà nel proprio database locale 
che l'evento si è verificato in quello specifico quadrante.
Le assunzioni sulla probabile quantità, in percentuale, di parcheggi liberi vengono calcolate sulla granularità della cella.
Quando due peer cercheranno di sincronizzarsi verranno scambiate le informazioni relative alla cella corrente e quelle adiacenti.
In questo modo, si cerca di fornire all'utente, previsioni più precise sulle celle che sono nei pressi della posizione corrente del device.
Questo evita overhead nella comunicazione e sincronizzazione di entries che non sono utili all'utente.
Rimanendo nel discorso di overhead, è normale pensare che questo modello possa ``esplodere``, in quanto la mole di dati potrebbe diventare enorme con il passare del tempo, così come le opportunità di sincronizzazione.
Per evitare che questo succeda, viene controllata la dimensione del db locale, ed eventualmente eliminate le entries meno aggiornate.
Inoltre i peers possono effettuare sincronizzazioni soltanto dopo una certa threshold, espressa in secondi.
Questi concetti sono stati parametrizzati in fase di implementazione, quindi possono essere giustamente calibrati in base all'ambiente in cui si intende utilizzare l'app.

\section{Architettura generale}               %crea la sezione
L'architettura generale, analizzandola da un punto di vista esterno, prevede come unici attori i device utenti. Questi muovendosi all'interno dell'ambiente città restano in attesa di possibili sincronizzazioni.
Ogni dispositivo, che presenta il servizio di comunicazione e sincronizzazione attivo, può interpretare fondamentalmente due ruoli concettuali:
\\\\ \textbf{ROLE ACCESS POINT}:
\\Il device funge da access point, offrendo la possibilità a device presenti in prossimità di agganciarsi all'HotSpot esposto. Una volta che un Client si connette stabilmente ad esso avrà  l'opportunità di aprire 
un canale di comunicazione e sincronizzare i propri dati con quelli del Access Point, denominato anche come Server.
Inoltre l'Access Point notifica la propria presenza e informazioni utili attraverso la propagazione di un beacon di servizio.
\\\\ \textbf{ROLE CLIENT}:
\\Se un device si accorge della presenza di un HotSpot nelle vicinanze, grazie al beacon sopra citato, può tentare di connettersi come Client all'Access Point. Qualora riesca ad agganciarsi in modo stabile all'HotSpot 
verranno avviati i canali di comunicazione, su cui effettuare una sincronizzazione tra i device Client e Server.
\\\\A questo punto la topologia della rete generale può essere vista come hub di hub, ovvero tante piccole star, dove grazie al movimento inerziale dei device si riuscirà ad ottenere una propagazione dell'informazione, 
interconnettendo appunto le informazioni di diversi hub tra di loro, ad istanti di tempo differenti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.6]{img/arch_general.png}
\caption{Rappresentazione dell'Architettura generale e della divisione in celle di una porzione di Bologna}
\end{figure}
\\\\Come si può comprendere dalla Fig. i device muovendosi continuamente all'interno dello scenario(identificato in questo caso con la griglia città), formeranno continuamente nuovi Hub, con attori sempre diversi. Questo 
fattore è determinante per il processo di propagazione delle informazioni, in quanto dati presenti in un Hub, verranno sincronizzati, in istanti successivi, con Hub diversi.
L'analisi dello spreading delle informazioni, la sua efficacia ed accuratezza sono illustrate nel capitolo di valutazione, nel quale si cerca di capire se questo meccanismo è attuabile nella realtà.

\section{Architettura software}               %crea la sezione
Prima della fase di implementazione, è stato necessaria una fase di progettazione dell'architettura software. L'applicazione, per essere considerata utilizzabile dagli utenti ed efficace nel meccanismo di 
spreading dell'informazione, necessita di numerosi componenti e soprattutto dell'interazione tra essi.
Nella Fig.XY sono stati messi i componenti principali che concettualmente compongono l'architettura e come questi collaborano.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/arch_soft.png}
\caption{Rappresentazione dell'Architettura software}
\end{figure}
\\\\ \textbf{Componente di Activity Recognition:}
\\Il componente di activity recognition si preoccupa di rilevare gli eventi di parcheggio e rilascio, che un determinato utente compie, col trascorrere del tempo. Questo è possibile tramite l'utilizzo dei sensori, 
i quali campionano periodicamente lo stato di accelerometro e giroscopio, mappandoli tramite un algoritmo decisionale in un'attività ben definita.
Questo processo, in realtà, si compone di due fase come training e recognition.
La prima è necessaria alla seconda e riguarda il campionamento dei dati sensore in una attività definita dall'utente di CAR o NO\_CAR. La seconda, invece, grazie ai campioni rilevati nella prima riuscirà a 
fare assunzione sul tipo di attività che l'utente sta svolgendo.
Quando il componente capisce che si è passato da uno stato CAR ad uno stato NO\_CAR, significa che l'utente ha parcheggiato l'autovettura, mentre, dualmente, se si passa da uno stato NO\_CAR a CAR, significa che 
l'utente ha rilasciato uno slot.
Quando una di queste due situazioni accade, si registra l'evento nel local DB.
\\\\ \textbf{Componente local DataBase:}
\\Il Database locale si preoccupa di persistere le informazioni sul device utente, le quali poi verranno processate per calcolare la probabilità di parcheggio in una determinata zona.
Le informazioni che vengono memorizzate sono illustrate più precisamente nel paragrafo XYZ.
\\\\ \textbf{Componente Controller:}
\\Il Controller si preoccupa di scrivere, aggiornare e dare accesso alle informazioni presenti nel database locale. Inoltre, è stato pensato come semplice meccanismo di Object-Relational Mapping(ORM), 
per integrare al meglio le logiche ad oggetti con i dati presenti nel DBMS. 
Sostanzialmente, può essere interpretato come un oggetto Controller, del pattern MVC(Model-View-Controller), gestendo ed implementando le classi del Modello.
\\\\ \textbf{Componente Frontend:}
\\Il frontend sono sostanzialmente le views che verranno mostrate all'utente, sul proprio device Android. Si è optato per un frontend semplice, per rendere utilizzabile l'app a qualsiasi tipo di utente, 
pur fornendo ad esso tutte le informazioni necessarie sullo stato dei parcheggi nelle vicinanze.
Nella sezione Screenshot è possibile prendere visione del layout grafico pensato per l'applicazione.
\\\\\textbf{ Componente Dissemination Service:}
\\Il componente di disseminazione delle informazioni è il cuore del progetto e l'elemento più articolato all'interno dell'architettura.
Questo è composto da diversi sottocomponenti, la maggior parte dei quali verranno illustrati con precisione nel capitolo di implementazione.
Il disseminatore è un servizio che gira in background e la logica è scandita da una FSM(Finite State Machine), dove in base allo stato in cui ci si trova verranno compiute azioni, piuttosto che altre.
Quando viene rilevata una nuova connessione ad un peer, essendo questo nel ruolo di client o server, il componente si preoccupa anche di gestire il corretto funzionamento della comunicazione, 
gestendo i canali di INPUT e OUTPUT verso gli altri device, nel range di comunicazione.

\section{Organizzazione dell'informazione}                 %crea la sezione
L'organizzazione e persistenza dei city data è ovviamente una fase determinante del progetto.
In fase di progettazione, si è giunti alla conclusione che non è sufficiente scambiarsi il numero di parcheggi liberi/occupati/unknow derivanti da dati statistici, 
in quanto ogni device/utente potrebbe avere una parziale, ma diversa, visione dello scenario.
Da ciò deriva la necessità di sincronizzarsi su tutti gli eventi che sono successi recentemente in una determinata zona(cella) e quelle adiacenti.
Si è optato per la realizzazione di un database di tipo relazionale composto principalmente da due tabelle, indipendenti l'una dall'altra.
La prima tabella, denominata, park\_events colleziona tutti gli eventi che gli utente compiono o ricevono in seguito a sincronizzazioni con altri utenti.
La seconda tabella synchronizations colleziona invece tutte le sincronizzazioni che hanno coinvolto il device in questione.
Come verrà illustrato nel capitolo relativo all'implementazione, gli strumenti utilizzati si baseranno completamente sullo standard SQL, i quali permetteranno una semplice gestione di 
query di filtraggio, creazione, modifica, cancellazione.
Entrando più in dettaglio nella composizione delle tabelle e degli attributi salvati, si mostra di seguito uno schema riassuntivo di ciò che viene messo a database.
\\\\ Tabella \textbf{park\_events}:
\begin{itemize}
\item cell\_id : identificativo univoco della cella che la identifica all'interno della grid city. Informazione di tipo geografica.
\item event : evento che può essere limitatamente PARKED o RELEASED. Indica se l'entry fa riferimento ad una sosta o alla liberazione di un parcheggio.
\item timestamp : datetime che indica il momento in cui è stato performato l'evento in questione.
\item mac : identificativo univoco del device che ha performato l'evento di parcheggio o rilascio.
\end{itemize}
La PRIMARY\_KEY è composta da \textless timestamp, mac \textgreater. L'idea che vi sta dietro è quella che un utente può performare, in un dato istante, al più un unico 
evento di rilascio o parcheggio.
\\\\ Tabella synchronizations:
\begin{itemize}
\item timestamp : datetime in cui è avvenuta la sincronizzazione
\item mac : id univoco dell'altro device con cui è stata possibile la sincronizzazione
\item ap\_role : booleano che indica se ero Access Point o meno al momento della sincronizzazione
\end{itemize}

Questa tabella oltre a fini statistici,  è importante perché permette di evitare che due device si sincronizzino in continuazione.
Grazie all'attributo timestamp, si riesce a risalire all'ultima sincronizzazione che ha coinvolto il device e di conseguenza, è possibile istanziare una time threshold, sotto la quale non è possibile iniziare una nuova sincronizzazione.
Le logiche implementate a backend non permettono lo scambio di dati in istanti troppo vicini tra loro.
Questo meccanismo può esser visto come un minimo di salvaguardia da cicli continui o sovrapposizione di sincronizzazioni.

\section{Network State Machine}                 %crea la sezione
Come già accennato nell'architettura software, il processo di disseminazione delle informazioni è scandito da una macchina a stati finiti.
Si è deciso di approfondire questo componente per far comprendere meglio come vengono gestite le sincronizzazioni tra i device utente coinvolti.
\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/nsm.png}
\caption{Rappresentazione dell'Architettura software}
\end{figure}
\\Alla partenza del servizio, il device, non ha conoscenza dell'ambiente circostante, di conseguenza si rende disponibile come ruolo di Access Point ed entra nello stato STATE\_ACCESS\_POINT\_NO\_PEERS.
Quando si riesce a scoprire la presenza di altri peer, nei paraggi, si entra nello stato STATE\_ACCESS\_POINT\_PEERS.
A questo punto, il device, si mette all'ascolto di eventuali beacon di servizio, i quali potrebbero notificare la presenza di un preesistente AccessPoint.
Se questo non accade, il device rimane disponibile come ruolo di Access Point, notificando la propria presenza in beaconing e fornendo opportunità di sincronizzazioni ad eventuali client in arrivo(stato OPEN\_SERVER\_SOCKET).
Diversamente, se il device comprende la presenza di un Access Point già consolidato in zona, smette di svolgere il ruolo di HotSpot e comincia a comportarsi come Client, entrando, di conseguenza, 
nello stato STATE\_CONNECTION.
Ora il device cerca di connettersi all'HotSpot, esposto grazie alla tecnologia WiFiDirect.
Se il processo porta ad una connessione stabile e ad un assegnazione di un indirizzo IP, verrà automaticamente aperto un canale di comunicazioni bidirezionali tra il Client e Server, iniziando così la fase 
di sincronizzazione(stato IN\_SYNC).
Come si può notare dallo schema in Fig XY, dallo stato STATE\_CONNECTION vi è anche la possibilità di ripartire dall'inizio, nel caso in cui, il device non riesca a connettersi all'HotSpot in un tempo ragionevole, 
impostando una threshold.
Questo è stato fatto per evitare situazioni di stallo e cercare di ripartire da un punto più stabile.
Supponendo che la sincronizzazione sia andata a buon fine, si passa allo stato STATE\_SYNCED\_CONNECTED, il quale significa che la sincronizzazione è terminata ma si è ancora agganciati all'HotSpot del Server.
A questo punto, gli attori coinvolti, potrebbero allontanarsi a tal punto da rompere il legame creato e quindi il servizio ripartirebbe dallo stato iniziale di START.
Altrimenti, se gli utenti restano nelle vicinanze l'uno dell'altro, in modo tale da mantenere attiva la connessione, si dà l'opportunità al Client(dopo una certa threshold) di richiedere nuovamente una sincronizzazione.

\section{Statistica}                 %crea la sezione
La parte di statistica si preoccupa, man mano che le informazioni giungono nel database locale, di calcolare le probabilità di trovare parcheggio in una determinata cella della città, piuttosto che in altre.
Si ricorda che il dato che si fornisce all'utente è una probabilità e non un valore certo, così da dare indicazioni agli utenti, sulle zone, che statisticamente saranno meno congestionate, in termini di occupazione.
Un'altra precisazione riguarda  il fatto che più utenti utilizzeranno l'applicazione, come supporto al parcheggio, e più dati verranno disseminati tra i device, aumentando progressivamente l'accuratezza 
delle probabilità fornite agli utenti.
Supponendo che il numero di slot totali in una cella, identificato con la sigla Nt, sia noto a priori, lo si può interpretare anche come la somma tra numero di slot liberi, Nf, e numero di slot occupati No.
Questi ultimi due, possono essere ricavati a partire dagli eventi di parcheggio e rilascio, i quali sono presenti nel database locale citato in precedenza.
In particolare, il numero dei parcheggi occupati No può essere ricavato dalla differenza tra il numero di eventi parcheggio Ep ed il numero di eventi rilascio Er.

$$N\ped{o}=\df{\partial}{\partial y}\boldsymbol{f}(x,y)$$

\subsection{Prima SottoSezione}         %crea la sottosezione
\begin{teo}[nome teorema] $\\$          %crea l'ambiente teorema e
                                        %   $\\$ va a capo in modo forzato
\vspace{-20pt}                          %toglie uno spazio verticale di 20pt

Primo Teorema.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%crea l'ambiente matematico $$ $$
                                        %   questo ambiente centra la
                                        %   formula ma non la numera
$$\df{\partial}{\partial x}\boldsymbol{f}(x,y)=\df{\partial}{\partial y}\boldsymbol{f}(x,y)$$
\end{teo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%crea l'ambiente dimostrazione
\begin{proof}Il teorema \`e dimostrato
\end{proof}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{oss}                             %crea l'ambiente osservazione
Prima Osservazione.
\end{oss}
\begin{oss}                             %crea l'ambiente osservazione
Seconda Osservazione.
\end{oss}
\begin{defin}
Altra definizione.
\end{defin}
Ora vediamo un elenco numerato:         %crea un elenco numerato
\begin{enumerate}
\item primo oggetto
\item secondo oggetto
\item terzo oggetto
\item quarto oggetto
\end{enumerate}
\begin{ese}                             %crea l'ambiente esempio
In questo primo esempio vediamo come si inserisce una figura:
\begin{figure}[h]                       %crea l'ambiente figura; [h] sta
                                        %   per here, cioè la figura va qui
\begin{center}                          %centra nel mezzo della pagina
                                        %   la figura
%\includegraphics[width=5cm]{figura.eps}%inserisce una figura larga 5cm
                                        %è commentata perché altrimenti
                                        %   produce errori
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%inserisce la legenda ed etichetta
                                        %   la figura con \label{fig:prima}
\caption[legenda elenco figure]{legenda sotto la figura}\label{fig:prima}
\end{center}
\end{figure}
\end{ese}
\begin{teo}$\\$                         %crea l'ambiente teorema e
                                        %   $\\$ va a capo in modo forzato

\vspace{-20pt}                          %toglie uno spazio verticale di 20pt
Secondo Teorema.
\end{teo}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%crea anche questo l'ambiente
                                        %   dimostrazione ed è equivalente
                                        %   al precendente
\proof Il teorema \`e dimostrato \endproof
\section{Terza Sezione}
\begin{ese}[nome esempio]$\\$

\vspace{-20pt}                          %toglie uno spazio verticale di 20pt
Secondo Esempio.
\newpage                                %va in una pagina nuova
Ora vediamo un elenco puntato:
\begin{itemize}                         %crea un elenco puntato
\item primo oggetto
\item secondo oggetto
\end{itemize}
\end{ese}
\section{Altra Sezione}
Vediamo un elenco descrittivo:
\begin{description}                     %crea un elenco descrittivo
  \item[OGGETTO1] prima descrizione;
  \item[OGGETTO2] seconda descrizione;
  \item[OGGETTO3] terza descrizione.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%crea una sottosezione etichettata
\subsection{Altra SottoSezione}\label{sec:newton}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%crea una sottosottosezione
\subsubsection{SottoSottoSezione}Questa sottosottosezione non viene
numerata, ma \`e solo scritta in grassetto.
\section{Altra Sezione}                 %crea una sottosezione
Vediamo la creazione di una tabella; la tabella \ref{tab:uno}
(richiamo il nome della tabella utilizzando la label che ho messo sotto):
la facciamo di tre righe e tre colonne, la prima colonna
``incolonnata'' a destra (r) e le altre centrate (c):\\
\begin{table}[h]                        %ambiente tabella
                                        %(serve per avere la legenda)
\begin{center}                          %centra nella pagina la tabella
\begin{tabular}{r|c|c}                  %tre colonne con righe verticali
                                        %   prodotte con |
\hline \hline                           %inserisce due righe orizzontali
$(1,1)$ & $(1,2)$ & $(1,3)$\\           %& separa le colonne e con
\hline                                  %inserisce una riga orizzontale
$(2,1)$ & $(2,2)$ & $(2,3)$\\           %  \\ va a capo
\hline                                  %inserisce una riga orizzontale
$(3,1)$ & $(3,2)$ & $(3,3)$\\
\hline \hline                           %inserisce due righe orizzontali
\end{tabular}
\caption[legenda elenco tabelle]{legenda tabella}\label{tab:uno}
\end{center}
\end{table}
\section{Altra Sezione}\label{sec:prova}%posso mettere le label anche
                                        %   alle section
\subsection{Listati dei programmi}
\subsubsection{Primo Listato}
\begin{verbatim}
        In questo ambiente     posso scrivere      come voglio,
lasciare gli spazi che voglio e non % commentare quando voglio
e ci sarà scritto tutto.
Quando lo uso è meglio che disattivi il Wrap del WinEdt
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%per fare le conclusioni
\chapter*{Conclusioni}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries
CONCLUSIONI}]{\fancyplain{}{\bfseries\thepage}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries
CONCLUSIONI}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Conclusioni
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Conclusioni} Queste sono le
conclusioni.\\
In queste conclusioni voglio fare un riferimento alla
bibliografia: questo \`e il mio riferimento \cite{K3,K4}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\renewcommand{\chaptermark}[1]{\markright{\thechapter \ #1}{}}
\lhead[\fancyplain{}{\bfseries\thepage}]{\fancyplain{}{\bfseries\rightmark}}
\appendix                               %imposta le appendici
\chapter{Prima Appendice}               %crea l'appendice
In questa Appendice non si \`e utilizzato il comando:\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\verb"" è equivalente all'
                                        %   ambiente verbatim,
                                        %   ma si utilizza all'interno
                                        %   di un discorso.
\verb"\clearpage{\pagestyle{empty}\cleardoublepage}", ed infatti
l'ultima pagina 8 ha l'intestazione con il numero di pagina in
alto.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries \thechapter \:Prima Appendice}]
{\fancyplain{}{\bfseries\thepage}}
\chapter{Seconda Appendice}             %crea l'appendice
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%imposta l'intestazione di pagina
\rhead[\fancyplain{}{\bfseries \thechapter \:Seconda Appendice}]
{\fancyplain{}{\bfseries\thepage}}
\begin{thebibliography}{90}             %crea l'ambiente bibliografia
\rhead[\fancyplain{}{\bfseries \leftmark}]{\fancyplain{}{\bfseries
\thepage}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%aggiunge la voce Bibliografia
                                        %   nell'indice
\addcontentsline{toc}{chapter}{Bibliografia}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%provare anche questo comando:
%%%%%%%%%%%\addcontentsline{toc}{chapter}{\numberline{}{Bibliografia}}
\bibitem{K1} Primo oggetto bibliografia.
\bibitem{K2} Secondo oggetto bibliografia.
\bibitem{K3} Terzo oggetto bibliografia.
\bibitem{K4} Quarto oggetto bibliografia.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%non numera l'ultima pagina sinistra
\clearpage{\pagestyle{empty}\cleardoublepage}
\chapter*{Ringraziamenti}
\thispagestyle{empty}
Qui possiamo ringraziare il mondo intero!!!!!!!!!!\\
Ovviamente solo se uno vuole, non \`e obbligatorio.
\end{document}
